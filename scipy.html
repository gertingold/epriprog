

<!DOCTYPE html>


<html lang="de" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>8. Numerische Programmbibliotheken am Beispiel von NumPy/SciPy &#8212; Einführung in Prinzipien der Programmierung</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'scipy';</script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="9. Objektorientiertes Programmieren" href="objektorientiert.html" />
    <link rel="prev" title="7. Ein- und Ausgabe" href="einausgabe.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="de"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Einführung in Prinzipien der Programmierung</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="einleitung.html">1. Einleitung</a></li>
<li class="toctree-l1"><a class="reference internal" href="vorschau.html">2. Eine Vorschau</a></li>
<li class="toctree-l1"><a class="reference internal" href="datentypen.html">3. Einfache Datentypen, Variablen und Zuweisungen</a></li>
<li class="toctree-l1"><a class="reference internal" href="kontrollstrukturen.html">4. Kontrollstrukturen</a></li>
<li class="toctree-l1"><a class="reference internal" href="funktionen.html">5. Funktionen</a></li>
<li class="toctree-l1"><a class="reference internal" href="sequenzen.html">6. Zusammengesetzte Datentypen</a></li>
<li class="toctree-l1"><a class="reference internal" href="einausgabe.html">7. Ein- und Ausgabe</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">8. Numerische Programmbibliotheken am Beispiel von NumPy/SciPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="objektorientiert.html">9. Objektorientiertes Programmieren</a></li>
<li class="toctree-l1"><a class="reference internal" href="zahlensysteme.html">10. Anhang: Zahlensysteme</a></li>
<li class="toctree-l1"><a class="reference internal" href="floats.html">11. Anhang: 64-Bit-Gleitkommazahlen nach IEEE-Standard 754</a></li>
<li class="toctree-l1"><a class="reference internal" href="unicode.html">12. Anhang: Unicode</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/git/https//github.com/gertingold/epriprog/master?urlpath=tree/epriprog/scipy.md" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Laden Sie diese Seite herunter">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/scipy.ipynb" target="_blank"
   class="btn btn-sm btn-download-notebook-button dropdown-item"
   title="Notebook-Datei herunterladen"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-code"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li><a href="_sources/scipy.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Quelldatei herunterladen"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="In PDF drucken"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Vollbildmodus"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Suche" aria-label="Suche" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Numerische Programmbibliotheken am Beispiel von NumPy/SciPy</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Inhalt </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#installation">8.1. Installation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#arrays-und-anwendungen">8.2. Arrays und Anwendungen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#numerische-integration">8.3. Numerische Integration</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integration-gewohnlicher-differentialgleichungen">8.4. Integration gewöhnlicher Differentialgleichungen</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="numerische-programmbibliotheken-am-beispiel-von-numpy-scipy">
<span id="scipy"></span><h1><span class="section-number">8. </span>Numerische Programmbibliotheken am Beispiel von NumPy/SciPy<a class="headerlink" href="#numerische-programmbibliotheken-am-beispiel-von-numpy-scipy" title="Permalink to this heading">#</a></h1>
<p>In den bisherigen Kapiteln hatten wir immer wieder Gelegenheit, auf
Möglichkeiten hinzuweisen, die die Python-Standardbibliothek bietet. Wenn man
die dort zur Verfügung gestellten Module verwendet, kann man sich Einiges an
Arbeit sparen und dabei auch den Code effizienter und übersichtlicher
gestalten.  Neben der Python-Standardbibliothek gibt es aber auch noch viele
interessante Programmpakete, die häufig über den <a class="reference external" href="https://pypi.org/">Python Package
Index</a> zur Verfügung gestellt werden.</p>
<p>Gerade für Problemstellungen in den Natur- und Ingenieurwissenschaften gibt es
eine oft als <em>scientific ecosystem of Python</em> oder <em>scientific stack</em>
bezeichnete Sammlung von zentralen Paketen. Hierzu gehört als Basispaket
zunächst <a class="reference external" href="http://numpy.org/">NumPy</a>, das den Datentyp <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> sowie Methoden
zur Verfügung stellt, um mit <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>-Objekten zu arbeiten. Damit wird das
Rechnen mit Vektoren und Matrizen ermöglicht, das wir bei der Besprechung von
Listen in <a class="reference internal" href="sequenzen.html#listen"><span class="std std-numref">Kapitel 6.1</span></a> vermisst hatten.</p>
<p>Ein weiteres wichtiges Paket ist <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>, das vielfältige numerische Werkzeuge zur Verfügung stellt, beispielsweise
zur numerischen Integration oder der Lösung von Differentialgleichungssystemen,
zur Lösung von Optimierungsproblemen oder zur Berechnung von speziellen
Funktion sowie vielem Anderem mehr. In diesem Kapitel werden wir einen
ersten Eindruck von den Möglichkeiten geben, die NumPy und SciPy bereitstellen.</p>
<p>Weitere zentrale Pakete, die in diesem Zusammenhang zu nennen sind, wären
<a class="reference external" href="http://matplotlib.org/">Matplotlib</a> zur graphischen Darstellung von Daten,
<a class="reference external" href="http://ipython.org/">IPython</a>, eine interaktive Python-Konsole, die für das
<a class="reference external" href="https://jupyter.org/">Projekt Jupyter</a>, das unter anderem die Jupyter
Notebooks zur Verfügung stellt, von zentraler Bedeutung war und ist,
<a class="reference external" href="http://sympy.org/">SymPy</a> für das symbolische Rechnen sowie das im
<a class="reference internal" href="einausgabe.html#readfile"><span class="std std-numref">Kapitel 7.2</span></a> bereits erwähnte <a class="reference external" href="http://pandas.pydata.org/">pandas</a>,
das fortgeschrittene Datenstrukturen und vielfältige Methoden zu einer
effizienten Datenanalyse bereithält.</p>
<p>Auf der Basis dieser Pakete haben einzelne wissenschaftliche Disziplinen
umfangreiche, auf ihre speziellen Bedürfnisse zugeschnittene Programmpakete
entwickelt. So kann <a class="reference external" href="https://www.astropy.org/">Astropy</a> als Standard in der
Astronomie angesehen werden. <a class="reference external" href="http://qutip.org/">QuTiP</a>, die <em>Quantum Toolbox
in Python</em> erlaubt die Simulation von Quantensystemen. Für Problemstellungen,
die sich mit finite-Elemente-Methoden lösen lassen, steht
<a class="reference external" href="https://fenicsproject.org/">FEniCS</a> zur Verfügung. Diese Aufzählung könnte
fast beliebig fortgesetzt werden und soll nur dazu dienen, einen allerersten
Eindruck von der Vielfalt der zur Verfügung stehenden
Python-Programmbibliotheken zu geben.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition seealso">
<p class="admonition-title">Siehe auch</p>
<p>Quellen für hier besprochene Programmpakete:
<a class="reference external" href="https://github.com/numpy/numpy">NumPy auf Github</a>,
<a class="reference external" href="https://github.com/scipy/scipy">SciPy auf Github</a></p>
</div>
</aside>
<p>Nachdem die Benutzung professioneller Programmpakete gelegentlich mit hohen
Kosten verbunden sein kann, ist es erwähnenswert, dass die hier aufgeführten
Pakete frei verfügbar, aber dennoch von sehr hoher Qualität sind. Zwei Beispiele
prominenter Forschungsprojekte, deren Arbeit wesentlich auf einigen der hier
genannten Pakete, sind in <a class="reference internal" href="einleitung.html#warumpython"><span class="std std-numref">Kapitel 1.2</span></a> genannt. Darüber hinaus ist
der Quellcode der Pakete verfügbar, so dass man sich bei Bedarf auch die
konkrete Implementierung ansehen sowie zur Weiterentwicklung beitragen kann.</p>
<section id="installation">
<h2><span class="section-number">8.1. </span>Installation<a class="headerlink" href="#installation" title="Permalink to this heading">#</a></h2>
<p>Da NumPy und SciPy nicht in der Python-Standardbibliothek enthalten sind, stehen
diese Programmpakete auch bei einer vorhandenen Python-Installation nicht
automatisch zur Verfügung. Dies lässt sich leicht überprüfen, indem man versucht,
die beiden Pakete zu importieren. Schlägt dies fehl, so erhält man einen
<code class="docutils literal notranslate"><span class="pre">ImportError</span></code>, der impliziert, dass Python die Pakete nicht finden kann.
Außerdem lässt sich die installierte Version anzeigen, was deswegen interessant
sein kann, weil gelegentlich neue Funktionalität zu den Paketen hinzugefügt
wird. Beachten Sie, dass vor und nach <code class="docutils literal notranslate"><span class="pre">version</span></code> jeweils zwei Unterstriche
stehen müssen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">numpy</span><span class="o">.</span><span class="n">__version__</span><span class="w"> </span><span class="si">= }</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span><span class="w"> </span><span class="si">= }</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>numpy.__version__ = &#39;1.25.2&#39;
scipy.__version__ = &#39;1.11.1&#39;
</pre></div>
</div>
</div>
</div>
<p>Eine einfache und empfehlenswerte Möglichkeit, NumPy und SciPy unter Windows,
MacOS oder Linuxvarianten wie Ubuntu verfügbar zu machen, besteht darin, die
<a class="reference external" href="https://www.anaconda.com/products/individual">Anaconda-Distribution</a> zu
installieren. Dabei werden allerdings gleichzeitig zahlreiche andere, für
wissenschaftliche Zwecke interessante Programmpakete installiert.  Ist dies
nicht erwünscht, zum Beispiel wegen des relativ großen Bedarfs an
Speicherplatz, kann man NumPy und SciPy auch gezielt auf einem der Wege
installieren, die in der <a class="reference external" href="https://numpy.org/install/">Installationsanleitung für
NumPy</a> und der <a class="reference external" href="https://www.scipy.org/install.html">Installationsanleitung für
SciPy</a> beschrieben sind.</p>
</section>
<section id="arrays-und-anwendungen">
<h2><span class="section-number">8.2. </span>Arrays und Anwendungen<a class="headerlink" href="#arrays-und-anwendungen" title="Permalink to this heading">#</a></h2>
<p>Für die Arbeit mit dem NumPy-Paket ist es üblich, für <code class="docutils literal notranslate"><span class="pre">numpy</span></code> die Abkürzung
<code class="docutils literal notranslate"><span class="pre">np</span></code> einzuführen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Dies bedeutet, dass man bei der Verwendung von NumPy vor die entsprechenden
Funktionen jeweils <code class="docutils literal notranslate"><span class="pre">np.</span></code> setzen muss. Diese Abkürzung verringert den Tippaufwand
und macht zum anderen sofort erkenntlich, wenn es sich um eine Funktion aus dem
NumPy-Paket handelt. Dies ist unter anderem deswegen wichtig, weil NumPy unter
anderem auch Funktionen wie die Exponentialfunktion <code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code> zur Verfügung
stellt, die von der Exponentialfunktion aus dem <code class="docutils literal notranslate"><span class="pre">math</span></code>-Modul unterschieden werden
muss.</p>
<p>Das zentrale Objekt, das durch das NumPy-Paket zur Verfügung gestellt wird, ist
das <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>, wobei die Abkürzung für N-dimensionales Array steht. Hiermit lassen
sich also Vektoren und Matrizen von im Prinzip beliebiger Dimension darstellen,
wobei alle Einträge vom gleichen Datentyp sind.</p>
<p>Es gibt eine ganze Reihe von Möglichkeiten, solche Arrays zu konstruieren. Wir
beginnen damit eine Matrix aus einer Liste oder im Allgemeinen Listen von Listen
zu erzeugen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matrixA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="mf">3.9</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">matrixA</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixA</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;numpy.ndarray&#39;&gt;
[[ 1.3  2.5]
 [-1.7  3.9]]
</pre></div>
</div>
</div>
</div>
<p>Für <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>s ist eine Matrixmultiplikation definiert. Um dies zu demonstrieren,
definieren wir ein zweites Array und führen die Matrixmultiplikation aus. Dafür
können wir die Funktion <code class="docutils literal notranslate"><span class="pre">np.dot</span></code> verwenden oder den <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>-Operator, der in moderneren
Versionen des NumPy-Pakets definiert ist. Anschließend überprüfen wir das Ergebnis
am 00-Element.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matrixB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.1</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixA</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixB</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixA</span> <span class="o">@</span> <span class="n">matrixB</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">matrixA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">*</span><span class="si">{</span><span class="n">matrixB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> + </span><span class="si">{</span><span class="n">matrixA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">*</span><span class="si">{</span><span class="n">matrixB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> = &#39;</span>
      <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">matrixA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">matrixB</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">matrixA</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">matrixB</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 1.3  2.5]
 [-1.7  3.9]]

[[ 2.1 -4.5]
 [ 0.9 -2.1]]

[[  4.98 -11.1 ]
 [ -0.06  -0.54]]

1.3*2.1 + 2.5*0.9 = 4.98
</pre></div>
</div>
</div>
</div>
<p>Dabei zeigen die letzten beiden Zeilen, wie man Elemente des Arrays adressieren
kann, nämlich indem die Indizes für die einzelnen Dimensionen durch Komma getrennt
in eckigen Klammern angegeben werden.</p>
<div class="warning admonition">
<p class="admonition-title">Multiplikationsoperatoren &#64; und *</p>
<p>Beachten Sie, dass der normale Multiplikationsoperator <code class="docutils literal notranslate"><span class="pre">*</span></code> die beiden Matrizen
elementweise multipliziert und somit keine Matrixmultiplikation ausführt, wie
es <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> verlangt. Probieren Sie es an einem Beispiel selbst aus!</p>
</div>
<p>Wie bei Listen kann die Adressierung auch mit Hilfe von Slices erfolgen, so dass
man bequem Untermatrizen extrahieren kann. Wichtig dabei ist, dass hier kein neues
Array erzeugt wird, sondern nur eine andere Sicht auf das bereits existierende Array
bereitgestellt wird. Dadurch ist ein solcher Zugriff sehr effizient. In diesem
Beispiel verwenden wird zur schnellen Erzeugung eines etwas größeren Arrays die
<code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code>-Funktion, die mit mit <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code> vergleichbar ist, aber eben ein
zunächst eindimensionales Array erzeugt. Dieses können wir dann mit der
<code class="xref py py-func docutils literal notranslate"><span class="pre">reshape()</span></code>-Methode beispielsweise in ein zweidimensionales Array umwandeln.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">matrixC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]
 [24 25 26 27 28 29]
 [30 31 32 33 34 35]]

[[ 9 10]
 [15 16]]
</pre></div>
</div>
</div>
</div>
<p>In der letzten Zeile extrahieren wir eine Untermatrix. Dabei bezieht sich das erste
Slice auf die Zeilen und das zweite Slice auf die Spalten. So können wir auch eine
Zerlegung in Blockmatrizen vornehmen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:])</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">3</span><span class="p">:])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0  1  2]
 [ 6  7  8]
 [12 13 14]]

[[ 3  4  5]
 [ 9 10 11]
 [15 16 17]]

[[18 19 20]
 [24 25 26]
 [30 31 32]]

[[21 22 23]
 [27 28 29]
 [33 34 35]]
</pre></div>
</div>
</div>
</div>
<p>Zudem kann die Möglichkeit eines Slices, die Schrittweite anzugeben, verwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">matrixC</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0  3]
 [12 15]
 [24 27]]
</pre></div>
</div>
</div>
</div>
<p>Während wir bei Listen gewohnt sind, diese mit der <code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code>-Methode um weitere
Elemente zu erweitern, sollte man ein solches Vorgehen bei Arrays vermeiden. Da dabei
jeweils ein neues Array erzeugt wird, wäre ein solches Vorgehen äußerst ineffizient.
Stattdessen legt man das Array zunächst in der benötigten Größe an, zum Beispiel mit
Hilfe von <code class="xref py py-func docutils literal notranslate"><span class="pre">np.zeros()</span></code> oder <code class="xref py py-func docutils literal notranslate"><span class="pre">np.ones()</span></code>. Das folgende Beispiel illustriert,
wie man die Dimension des Arrays sowie den Datentyp festlegen kann und was die
Multiplikation des Arrays mit einer Zahl bedeutet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[[5, 5, 5, 5],
        [5, 5, 5, 5],
        [5, 5, 5, 5]],

       [[5, 5, 5, 5],
        [5, 5, 5, 5],
        [5, 5, 5, 5]]])
</pre></div>
</div>
</div>
</div>
<div class="warning admonition">
<p class="admonition-title">Integer-Arrays</p>
<p>Bei Python sind wir gewohnt, dass Integer im Prinzip beliebig groß werden können.
Bei <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>s mit Datentyp Integer ist dies nicht der Fall. Der mögliche
Zahlenbereich ist je nach dem gewählten Integertyp eingeschränkt. Genaueres hierzu
findet man in der <a class="reference external" href="https://numpy.org/doc/stable/user/basics.types.html">NumPy-Dokumentation zu Datentypen</a>.</p>
</div>
<p>Statt NumPy-Arrays im Detail zu diskutieren, wollen wir im Folgenden einen Eindruck von
einigen Möglichkeiten geben, die dieser Datentyp bietet. Für die Arbeit mit <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>s
sollten man sich aber auf jeden Fall genauer mit diesen vertraut machen. Wir verweisen
hierzu zum Beispiel auf die <a class="reference external" href="https://numpy.org/doc/stable/">NumPy-Dokumentation</a>, aber auch
auf <a class="reference external" href="https://youtu.be/R2rCYf3pv-M">Teil 1</a> und <a class="reference external" href="https://youtu.be/sunNXIxIGV8">Teil 2</a> eines
Videotutorials.</p>
<p>Zu Beginn des Kapitels hatten wir gesehen, wie man Matrizen miteinander multiplizieren kann.
Für Vektoren erhält man auf diese Weise unmittelbar das Skalarprodukt. Darüber hinaus kann man
auch das Kreuzprodukt und das dyadische Produkt mit Hilfe von NumPy berechnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">vecA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">vecB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">))</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">))</span>
<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">vecA</span><span class="p">,</span> <span class="n">vecB</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-2

[ 0  0 23]

[[ 10   8   0]
 [-15 -12   0]
 [  0   0   0]]
</pre></div>
</div>
</div>
</div>
<p>Statt <code class="xref py py-func docutils literal notranslate"><span class="pre">np.dot()</span></code> hätten wir natürlich auch wieder den <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>-Operator verwenden können.</p>
<p>Interessant sind die von NumPy zur Verfügung gestellten <em>universal functions</em> oder <em>ufuncs</em>,
die als Argumente NumPy-Arrays akzeptieren und damit effizient Funktionen in einem Schritt
für eine größere Anzahl von Argumenten auswerten können. In dem folgenden Beispiel demonstrieren
wir zugleich die Verwendung der <code class="xref py py-func docutils literal notranslate"><span class="pre">linspace()</span></code>-Funktion, um eine Liste äquidistanter Werte
zu erzeugen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.  0.2 0.4 0.6 0.8 1.  1.2 1.4 1.6 1.8 2. ]
[1.         1.22140276 1.4918247  1.8221188  2.22554093 2.71828183
 3.32011692 4.05519997 4.95303242 6.04964746 7.3890561 ]
</pre></div>
</div>
</div>
</div>
<p>Die Exponentialfunktion aus dem <code class="docutils literal notranslate"><span class="pre">math</span></code>-Modul ist dagegen nicht in der Lage, NumPy-Arrays als
Argument zu akzeptieren.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="n">line</span> <span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="kn">import</span> <span class="nn">math</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="ne">TypeError</span>: only length-1 arrays can be converted to Python scalars
</pre></div>
</div>
</div>
</div>
<p>An dieser Stelle wird deutlich, wie nützlich es sein kann, aus dem Code direkt ersehen zu
können, aus welchem Modul die Exponentialfunktion verwendet wird. Das NumPy-Paket stellt
<em>ufuncs</em> für die üblichen Standardfunktionen zur Verfügung. Für viele spezielle Funktionen
wird man im SciPy-Paket fündig.</p>
<p>Zum Abschluss dieses kurzen Einblicks in das NumPy-Paket wollen wir noch einen Blick auf
häufig benötigte Funktionen aus der linearen Algebra werfen. Diese befinden sich im <code class="docutils literal notranslate"><span class="pre">linalg</span></code>-Modul
von NumPy, das üblicherweise unter dem Namen <code class="docutils literal notranslate"><span class="pre">LA</span></code> importiert wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">LA</span>
</pre></div>
</div>
</div>
</div>
<p>Für die Beispiele verwenden wir der Übersichtlichkeit halber nur 2×2-Matrizen, für die wir
alle Rechnungen natürlich auch leicht analytisch durchführen könnten. Selbstverständlich kann
NumPy auch mit viel größeren Matrizen umgehen. Wir definieren also eine 2×2-Matrix und berechnen
zunächst ihre Determinante.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1.0
</pre></div>
</div>
</div>
</div>
<p>Als nächstes berechnen wir die Inverse und obwohl bei diesem Wert der Determinante die Korrektheit
des Ergebnisses mehr oder weniger offensichtlich ist, berechnen wir gleich noch das Produkt
aus der Matrix und ihrer Inversen, das erwartungsgemäß die Einheitsmatrix ergibt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">a_inv</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a_inv</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">@</span> <span class="n">a_inv</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[-5.  3.]
 [ 2. -1.]]
[[1. 0.]
 [0. 1.]]
</pre></div>
</div>
</div>
</div>
<p>Für Anwendungen sehr wichtig ist die Möglichkeit, Eigenwertprobleme zu lösen. Berechnen wir also
die Eigenwerte und Eigenvektoren der Matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eigenwerte</span><span class="p">,</span> <span class="n">eigenvektoren</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">eigenwerte</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">eigenwerte</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">eigenwerte</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">eigenvektoren</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[-0.16227766  6.16227766]
-0.9999999999999984
[[-0.93246475 -0.50245469]
 [ 0.36126098 -0.86460354]]
</pre></div>
</div>
</div>
</div>
<p>der zweiten Ausgabezeile entnehmen als ersten Test, dass das Produkt der Eigenwerte, bis auf
Rundungsfehler, gleich der oben erhaltenen Determinanten ist. Überprüfen wir zum Abschluss noch
die Korrektheit der Eigenvektoren.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">@</span> <span class="n">eigenvektoren</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">],</span>
          <span class="n">eigenwerte</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">eigenvektoren</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[ 0.1513182  -0.05862459] [ 0.1513182  -0.05862459]
[-3.09626531 -5.32792709] [-3.09626531 -5.32792709]
</pre></div>
</div>
</div>
</div>
<p>Da der erste Index des Array <code class="docutils literal notranslate"><span class="pre">eigenvektoren</span></code> der Zeilenindex ist, während der zweite Index der
Spaltenindex ist, sehen wir, dass die Eigenvektoren in diesem Array in den Spalten stehen.</p>
</section>
<section id="numerische-integration">
<h2><span class="section-number">8.3. </span>Numerische Integration<a class="headerlink" href="#numerische-integration" title="Permalink to this heading">#</a></h2>
<p>SciPy ist eine umfangreiche numerische Bibliothek, die wesentlich auf dem gerade besprochenen
NumPy-Paket basiert. Sie deckt vielfältige Problemstellungen ab wie zum Beispiel numerische
Integration und Lösung von gewöhnlichen Differentialgleichungen, Interpolation, Fouriertransformation,
Lösung von Optimierungsproblemen und Nullstellensuche, Signalverarbeitung oder spezielle
mathematische Funktionen. Hier wird es uns nur möglich sein, einen ersten Eindruck davon zu geben,
wie man mit Hilfe von SciPy numerische Problemstellungen lösen kann. Wir wollen dies anhand der
numerischen Auswertung von Integralen sowie der Lösung einer gewöhnlichen Differentialgleichung tun.</p>
<p>In diesem Kapitel wollen wir an zwei Beispielen die Auswertung von Integralen und zeigen und betrachten
zunächst das Integral</p>
<div class="math notranslate nohighlight">
\[J_0(1) = \frac{1}{\pi}\int_0^\pi\cos\!\big(\!\cos(x)\big)\text{d}x\,.\]</div>
<p>Das Ergebnis lässt sich durch eine spezielle Funktion, nämlich die Besselfunktion erster Gattung und
nullter Ordnung <span class="math notranslate nohighlight">\(J_0\)</span>, an der Stelle angeben. Mit Hilfe des SciPy-Pakets können wir sowohl das
Integral auf der rechten Seite als auch die Besselfunktion auf der linken Seite unabhängig voneinander
auswerten lassen und die beiden Ergebnisse miteinander vergleichen. Betrachten wir zunächst die
numerische Integration. Hierfür steht im <code class="docutils literal notranslate"><span class="pre">integrate</span></code>-Modul die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">quad()</span></code> zur Verfügung,
die als wesentliche Argumente den Integranden und die Integrationsgrenzen erwartet. Darüber hinaus
gibt es noch weitere Argumente, die wir hier einfach auf ihren Defaultwerten belassen. Den Integranden
stellen wir mit Hilfe einer Lambdafunktion zur Verfügung.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>

<span class="n">resultat</span><span class="p">,</span> <span class="n">fehler</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cos</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">resultat</span><span class="p">,</span> <span class="n">fehler</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.7651976865579665 7.610963315273956e-11
</pre></div>
</div>
</div>
</div>
<p>Wir erhalten sowohl das Resultat des numerischen Fehlers als auch eine Abschätzung für den absoluten
Integrationsfehler.</p>
<p>Zum Vergleich werten wir die Besselfunktion <span class="math notranslate nohighlight">\(J_0\)</span> nun direkt an der Stelle 1 aus. Dazu importieren
wir die entsprechende Funktion aus dem <code class="docutils literal notranslate"><span class="pre">special</span></code>-Modul von SciPy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">j0</span>

<span class="nb">print</span><span class="p">(</span><span class="n">j0</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.7651976865579665
</pre></div>
</div>
</div>
</div>
<p>In diesem Fall stimmen die beiden Ergebnisse perfekt überein, was aber im Allgemeinen nicht erwartet
werden kann. Problematisch sind insbesondere Integranden, die Singularitäten enthalten oder sehr
schnell oszillieren.</p>
<p>Um zu demonstrieren, dass SciPy auch mit uneigentlichen Integralen umgehen kann, betrachten wir noch
das Integral</p>
<div class="math notranslate nohighlight">
\[\int_{-\infty}^\infty\frac{1}{x^2+1}\text{d}x = \pi\,,\]</div>
<p>dessen Wert man ebenfalls analytisch kennt. Dies erlaubt uns wiederum, einen Eindruck davon zu gewinnen,
wie gut das Integrationsergebnis ist. Um mit den Integrationsgrenzen umzugehen, verwenden wir die
Konstante <code class="docutils literal notranslate"><span class="pre">inf</span></code> aus NumPy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">resultat</span><span class="p">,</span> <span class="n">fehler</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">resultat</span><span class="p">,</span> <span class="n">fehler</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.141592653589793 5.155583041103855e-10
3.141592653589793
</pre></div>
</div>
</div>
</div>
<p>Auch in diesem Fall ist die Übereinstimmung perfekt, so dass wir nochmals betonen wollen, dass dies
im Allgemeinen keineswegs zu erwarten ist.</p>
<p>Neben der Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">quad()</span></code> stellt noch weitere Funktionen zur Verfügung, in denen zum Beispiel
andere Integrationsverfahren verwendet werden oder mit denen auch mehrdimensionale Integrale
berechnet werden können. Weitere Informationen findet man in der <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/integrate.html#integrating-functions-given-function-object">Dokumentation des
<code class="docutils literal notranslate"><span class="pre">scipy.integrate</span></code>-Moduls</a>.</p>
</section>
<section id="integration-gewohnlicher-differentialgleichungen">
<h2><span class="section-number">8.4. </span>Integration gewöhnlicher Differentialgleichungen<a class="headerlink" href="#integration-gewohnlicher-differentialgleichungen" title="Permalink to this heading">#</a></h2>
<p>In Natur- und Ingenieurwissenschaften steht man häufig vor der Aufgabe, Differentialgleichungen numerisch
zu lösen, wobei zwischen gewöhnlichen und partiellen Differentialgleichungen sowie zwischen Anfangs- und
Randwertproblemen unterschieden werden muss. In diesem Kapitel wollen wir anhand von zwei Beispielen zeigen,
wie mit Hilfe von SciPy gewöhnliche Differentialgleichungen mit Anfangsbedingungen gelöst werden können.
Dazu werden wir die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code> aus dem <code class="docutils literal notranslate"><span class="pre">integrate</span></code>-Modul verwenden, wobei <code class="docutils literal notranslate"><span class="pre">ivp</span></code> als Abkürzung
für <em>initial value problem</em> zu lesen ist.</p>
<p>Zunächst ist es sinnvoll, sich darüber zu informieren, wie diese Funktion aufzurufen ist.</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>

<span class="n">help</span><span class="p">(</span><span class="n">solve_ivp</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on function solve_ivp in module scipy.integrate._ivp.ivp:

solve_ivp(fun, t_span, y0, method=&#39;RK45&#39;, t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options)
    Solve an initial value problem for a system of ODEs.
    
    This function numerically integrates a system of ordinary differential
    equations given an initial value::
    
        dy / dt = f(t, y)
        y(t0) = y0
    
    Here t is a 1-D independent variable (time), y(t) is an
    N-D vector-valued function (state), and an N-D
    vector-valued function f(t, y) determines the differential equations.
    The goal is to find y(t) approximately satisfying the differential
    equations, given an initial value y(t0)=y0.
    
    Some of the solvers support integration in the complex domain, but note
    that for stiff ODE solvers, the right-hand side must be
    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).
    To solve a problem in the complex domain, pass y0 with a complex data type.
    Another option always available is to rewrite your problem for real and
    imaginary parts separately.
    
    Parameters
    ----------
    fun : callable
        Right-hand side of the system: the time derivative of the state ``y``
        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a
        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. ``fun`` must
        return an array of the same shape as ``y``. See `vectorized` for more
        information.
    t_span : 2-member sequence
        Interval of integration (t0, tf). The solver starts with t=t0 and
        integrates until it reaches t=tf. Both t0 and tf must be floats
        or values interpretable by the float conversion function.
    y0 : array_like, shape (n,)
        Initial state. For problems in the complex domain, pass `y0` with a
        complex data type (even if the initial value is purely real).
    method : string or `OdeSolver`, optional
        Integration method to use:
    
            * &#39;RK45&#39; (default): Explicit Runge-Kutta method of order 5(4) [1]_.
              The error is controlled assuming accuracy of the fourth-order
              method, but steps are taken using the fifth-order accurate
              formula (local extrapolation is done). A quartic interpolation
              polynomial is used for the dense output [2]_. Can be applied in
              the complex domain.
            * &#39;RK23&#39;: Explicit Runge-Kutta method of order 3(2) [3]_. The error
              is controlled assuming accuracy of the second-order method, but
              steps are taken using the third-order accurate formula (local
              extrapolation is done). A cubic Hermite polynomial is used for the
              dense output. Can be applied in the complex domain.
            * &#39;DOP853&#39;: Explicit Runge-Kutta method of order 8 [13]_.
              Python implementation of the &quot;DOP853&quot; algorithm originally
              written in Fortran [14]_. A 7-th order interpolation polynomial
              accurate to 7-th order is used for the dense output.
              Can be applied in the complex domain.
            * &#39;Radau&#39;: Implicit Runge-Kutta method of the Radau IIA family of
              order 5 [4]_. The error is controlled with a third-order accurate
              embedded formula. A cubic polynomial which satisfies the
              collocation conditions is used for the dense output.
            * &#39;BDF&#39;: Implicit multi-step variable-order (1 to 5) method based
              on a backward differentiation formula for the derivative
              approximation [5]_. The implementation follows the one described
              in [6]_. A quasi-constant step scheme is used and accuracy is
              enhanced using the NDF modification. Can be applied in the
              complex domain.
            * &#39;LSODA&#39;: Adams/BDF method with automatic stiffness detection and
              switching [7]_, [8]_. This is a wrapper of the Fortran solver
              from ODEPACK.
    
        Explicit Runge-Kutta methods (&#39;RK23&#39;, &#39;RK45&#39;, &#39;DOP853&#39;) should be used
        for non-stiff problems and implicit methods (&#39;Radau&#39;, &#39;BDF&#39;) for
        stiff problems [9]_. Among Runge-Kutta methods, &#39;DOP853&#39; is recommended
        for solving with high precision (low values of `rtol` and `atol`).
    
        If not sure, first try to run &#39;RK45&#39;. If it makes unusually many
        iterations, diverges, or fails, your problem is likely to be stiff and
        you should use &#39;Radau&#39; or &#39;BDF&#39;. &#39;LSODA&#39; can also be a good universal
        choice, but it might be somewhat less convenient to work with as it
        wraps old Fortran code.
    
        You can also pass an arbitrary class derived from `OdeSolver` which
        implements the solver.
    t_eval : array_like or None, optional
        Times at which to store the computed solution, must be sorted and lie
        within `t_span`. If None (default), use points selected by the solver.
    dense_output : bool, optional
        Whether to compute a continuous solution. Default is False.
    events : callable, or list of callables, optional
        Events to track. If None (default), no events will be tracked.
        Each event occurs at the zeros of a continuous function of time and
        state. Each function must have the signature ``event(t, y)`` and return
        a float. The solver will find an accurate value of `t` at which
        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default, all
        zeros will be found. The solver looks for a sign change over each step,
        so if multiple zero crossings occur within one step, events may be
        missed. Additionally each `event` function might have the following
        attributes:
    
            terminal: bool, optional
                Whether to terminate integration if this event occurs.
                Implicitly False if not assigned.
            direction: float, optional
                Direction of a zero crossing. If `direction` is positive,
                `event` will only trigger when going from negative to positive,
                and vice versa if `direction` is negative. If 0, then either
                direction will trigger event. Implicitly 0 if not assigned.
    
        You can assign attributes like ``event.terminal = True`` to any
        function in Python.
    vectorized : bool, optional
        Whether `fun` can be called in a vectorized fashion. Default is False.
    
        If ``vectorized`` is False, `fun` will always be called with ``y`` of
        shape ``(n,)``, where ``n = len(y0)``.
    
        If ``vectorized`` is True, `fun` may be called with ``y`` of shape
        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave
        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of
        the returned array is the time derivative of the state corresponding
        with a column of ``y``).
    
        Setting ``vectorized=True`` allows for faster finite difference
        approximation of the Jacobian by methods &#39;Radau&#39; and &#39;BDF&#39;, but
        will result in slower execution for other methods and for &#39;Radau&#39; and
        &#39;BDF&#39; in some circumstances (e.g. small ``len(y0)``).
    args : tuple, optional
        Additional arguments to pass to the user-defined functions.  If given,
        the additional arguments are passed to all user-defined functions.
        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,
        then `jac` (if given) and any event functions must have the same
        signature, and `args` must be a tuple of length 3.
    **options
        Options passed to a chosen solver. All options available for already
        implemented solvers are listed below.
    first_step : float or None, optional
        Initial step size. Default is `None` which means that the algorithm
        should choose.
    max_step : float, optional
        Maximum allowed step size. Default is np.inf, i.e., the step size is not
        bounded and determined solely by the solver.
    rtol, atol : float or array_like, optional
        Relative and absolute tolerances. The solver keeps the local error
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a
        relative accuracy (number of correct digits), while `atol` controls
        absolute accuracy (number of correct decimal places). To achieve the
        desired `rtol`, set `atol` to be smaller than the smallest value that
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the
        number of correct digits is not guaranteed. Conversely, to achieve the
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller
        than `atol`. If components of y have different scales, it might be
        beneficial to set different `atol` values for different components by
        passing array_like with shape (n,) for `atol`. Default values are
        1e-3 for `rtol` and 1e-6 for `atol`.
    jac : array_like, sparse_matrix, callable or None, optional
        Jacobian matrix of the right-hand side of the system with respect
        to y, required by the &#39;Radau&#39;, &#39;BDF&#39; and &#39;LSODA&#39; method. The
        Jacobian matrix has shape (n, n) and its element (i, j) is equal to
        ``d f_i / d y_j``.  There are three ways to define the Jacobian:
    
            * If array_like or sparse_matrix, the Jacobian is assumed to
              be constant. Not supported by &#39;LSODA&#39;.
            * If callable, the Jacobian is assumed to depend on both
              t and y; it will be called as ``jac(t, y)``, as necessary.
              For &#39;Radau&#39; and &#39;BDF&#39; methods, the return value might be a
              sparse matrix.
            * If None (default), the Jacobian will be approximated by
              finite differences.
    
        It is generally recommended to provide the Jacobian rather than
        relying on a finite-difference approximation.
    jac_sparsity : array_like, sparse matrix or None, optional
        Defines a sparsity structure of the Jacobian matrix for a finite-
        difference approximation. Its shape must be (n, n). This argument
        is ignored if `jac` is not `None`. If the Jacobian has only few
        non-zero elements in *each* row, providing the sparsity structure
        will greatly speed up the computations [10]_. A zero entry means that
        a corresponding element in the Jacobian is always zero. If None
        (default), the Jacobian is assumed to be dense.
        Not supported by &#39;LSODA&#39;, see `lband` and `uband` instead.
    lband, uband : int or None, optional
        Parameters defining the bandwidth of the Jacobian for the &#39;LSODA&#39;
        method, i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``.
        Default is None. Setting these requires your jac routine to return the
        Jacobian in the packed format: the returned array must have ``n``
        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are
        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.
        The same format is used in `scipy.linalg.solve_banded` (check for an
        illustration).  These parameters can be also used with ``jac=None`` to
        reduce the number of Jacobian elements estimated by finite differences.
    min_step : float, optional
        The minimum allowed step size for &#39;LSODA&#39; method.
        By default `min_step` is zero.
    
    Returns
    -------
    Bunch object with the following fields defined:
    t : ndarray, shape (n_points,)
        Time points.
    y : ndarray, shape (n, n_points)
        Values of the solution at `t`.
    sol : `OdeSolution` or None
        Found solution as `OdeSolution` instance; None if `dense_output` was
        set to False.
    t_events : list of ndarray or None
        Contains for each event type a list of arrays at which an event of
        that type event was detected. None if `events` was None.
    y_events : list of ndarray or None
        For each value of `t_events`, the corresponding value of the solution.
        None if `events` was None.
    nfev : int
        Number of evaluations of the right-hand side.
    njev : int
        Number of evaluations of the Jacobian.
    nlu : int
        Number of LU decompositions.
    status : int
        Reason for algorithm termination:
    
            * -1: Integration step failed.
            *  0: The solver successfully reached the end of `tspan`.
            *  1: A termination event occurred.
    
    message : string
        Human-readable description of the termination reason.
    success : bool
        True if the solver reached the interval end or a termination event
        occurred (``status &gt;= 0``).
    
    References
    ----------
    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta
           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6,
           No. 1, pp. 19-26, 1980.
    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics
           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.
    .. [3] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;,
           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.
    .. [4] E. Hairer, G. Wanner, &quot;Solving Ordinary Differential Equations II:
           Stiff and Differential-Algebraic Problems&quot;, Sec. IV.8.
    .. [5] `Backward Differentiation Formula
            &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_
            on Wikipedia.
    .. [6] L. F. Shampine, M. W. Reichelt, &quot;THE MATLAB ODE SUITE&quot;, SIAM J. SCI.
           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.
    .. [7] A. C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE
           Solvers,&quot; IMACS Transactions on Scientific Computation, Vol 1.,
           pp. 55-64, 1983.
    .. [8] L. Petzold, &quot;Automatic selection of methods for solving stiff and
           nonstiff systems of ordinary differential equations&quot;, SIAM Journal
           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,
           1983.
    .. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on
           Wikipedia.
    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, &quot;On the estimation of
            sparse Jacobian matrices&quot;, Journal of the Institute of Mathematics
            and its Applications, 13, pp. 117-120, 1974.
    .. [11] `Cauchy-Riemann equations
             &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on
             Wikipedia.
    .. [12] `Lotka-Volterra equations
            &lt;https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations&gt;`_
            on Wikipedia.
    .. [13] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential
            Equations I: Nonstiff Problems&quot;, Sec. II.
    .. [14] `Page with original Fortran code of DOP853
            &lt;http://www.unige.ch/~hairer/software.html&gt;`_.
    
    Examples
    --------
    Basic exponential decay showing automatically chosen time points.
    
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from scipy.integrate import solve_ivp
    &gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y
    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])
    &gt;&gt;&gt; print(sol.t)
    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806
      8.33328988 10.        ]
    &gt;&gt;&gt; print(sol.y)
    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045
      0.03107158 0.01350781]
     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091
      0.06214316 0.02701561]
     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181
      0.12428631 0.05403123]]
    
    Specifying points where the solution is desired.
    
    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],
    ...                 t_eval=[0, 1, 2, 4, 10])
    &gt;&gt;&gt; print(sol.t)
    [ 0  1  2  4 10]
    &gt;&gt;&gt; print(sol.y)
    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]
     [4.         2.42610739 1.47068043 0.54133472 0.02701876]
     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]
    
    Cannon fired upward with terminal event upon impact. The ``terminal`` and
    ``direction`` fields of an event are applied by monkey patching a function.
    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts
    at position 0 with velocity +10. Note that the integration never reaches
    t=100 because the event is terminal.
    
    &gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5]
    &gt;&gt;&gt; def hit_ground(t, y): return y[0]
    &gt;&gt;&gt; hit_ground.terminal = True
    &gt;&gt;&gt; hit_ground.direction = -1
    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)
    &gt;&gt;&gt; print(sol.t_events)
    [array([40.])]
    &gt;&gt;&gt; print(sol.t)
    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]
    
    Use `dense_output` and `events` to find position, which is 100, at the apex
    of the cannonball&#39;s trajectory. Apex is not defined as terminal, so both
    apex and hit_ground are found. There is no information at t=20, so the sol
    attribute is used to evaluate the solution. The sol attribute is returned
    by setting ``dense_output=True``. Alternatively, the `y_events` attribute
    can be used to access the solution at the time of the event.
    
    &gt;&gt;&gt; def apex(t, y): return y[1]
    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10],
    ...                 events=(hit_ground, apex), dense_output=True)
    &gt;&gt;&gt; print(sol.t_events)
    [array([40.]), array([20.])]
    &gt;&gt;&gt; print(sol.t)
    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02
     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]
    &gt;&gt;&gt; print(sol.sol(sol.t_events[1][0]))
    [100.   0.]
    &gt;&gt;&gt; print(sol.y_events)
    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]
    
    As an example of a system with additional parameters, we&#39;ll implement
    the Lotka-Volterra equations [12]_.
    
    &gt;&gt;&gt; def lotkavolterra(t, z, a, b, c, d):
    ...     x, y = z
    ...     return [a*x - b*x*y, -c*y + d*x*y]
    ...
    
    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`
    argument.
    
    &gt;&gt;&gt; sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),
    ...                 dense_output=True)
    
    Compute a dense solution and plot it.
    
    &gt;&gt;&gt; t = np.linspace(0, 15, 300)
    &gt;&gt;&gt; z = sol.sol(t)
    &gt;&gt;&gt; import matplotlib.pyplot as plt
    &gt;&gt;&gt; plt.plot(t, z.T)
    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)
    &gt;&gt;&gt; plt.legend([&#39;x&#39;, &#39;y&#39;], shadow=True)
    &gt;&gt;&gt; plt.title(&#39;Lotka-Volterra System&#39;)
    &gt;&gt;&gt; plt.show()
</pre></div>
</div>
</div>
</div>
<p>Wichtig für uns ist insbesondere die Beschreibung zu Beginn des Hilfetexts sowie die ersten Argumente.
Für die weiter hinten stehenden Argumente ist es zunächst sinnvoll, die Defaultwerte zu belassen.
Interessant ist aber auch das Ende des Hilfetexts, wo einige konkrete Beispiele aufgeführt werden.</p>
<p>Wie wir der Beschreibung entnehmen können, ist <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code> in der Lage, Systeme gewöhnlicher
Differentialgleichungen zu lösen. Wir wollen mit dem einfachsten Fall, nämlich einer einzigen
Differentialgleichung erster Ordnung, beginnen. Konkret wollen wir die Differentialgleichung</p>
<div class="math notranslate nohighlight">
\[\dot x = -x^2\]</div>
<p>mit der Anfangsbedingung <span class="math notranslate nohighlight">\(x(0)=1\)</span> lösen. Hierbei handelt es sich um eine nichtlineare Differentialgleichung,
die sich mittels des Verfahrens der Trennung der Variablen analytisch lösen lässt. Die zugehörige Lösung</p>
<div class="math notranslate nohighlight">
\[x(t) = \frac{1}{1+t}\]</div>
<p>erlaubt es uns, die Qualität der numerischen Lösung einzuschätzen. Wie wir dem Hilfetext entnehmen
können, besitzen die ersten drei Argumente keinen Defaultwert, so dass wir diese Argumente auf jeden
Fall spezifizieren müssen. Dabei handelt es sich um die Funktion auf der rechten Seite der Differentialgleichung</p>
<div class="math notranslate nohighlight">
\[\frac{\text{d}y}{\text{d}t} = f(t, y)\,,\]</div>
<p>um ein Tupel, das die Anfangszeit <span class="math notranslate nohighlight">\(t_\text{i}\)</span> und die Endzeit <span class="math notranslate nohighlight">\(t_\text{f}\)</span> enthält, sowie den oder
die Anfangswerte <span class="math notranslate nohighlight">\(y(0)\)</span>. Zu beachten ist, dass <span class="math notranslate nohighlight">\(t\)</span> eine allgemeine unabhängige Variable ist, also keineswegs
die Bedeutung einer Zeit haben muss. <span class="math notranslate nohighlight">\(y\)</span> ist in unserem Fall eine skalare Funktion, für Systeme von
Differentialgleichungen dagegen eine vektorwertige Funktion. Entsprechend ist <span class="math notranslate nohighlight">\(y(0)\)</span> entweder ein Skalar
oder ein Vektor.</p>
<p>Damit sind wir nun in der Lage, <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code> zur Lösung unserer Differentialgleichung einzusetzen.
Um hinreichend viele Datenpunkte für eine graphische Darstellung zu erhalten, wollen wir außerdem die
gewünschten Zeitpunkte festlegen, zu denen die Lösung ausgegeben wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">t_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">t_span</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="n">t_eval</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>An dieser Stelle sind noch ein paar Anmerkungen sinnvoll. Der Anfangswert <code class="docutils literal notranslate"><span class="pre">y0</span></code> muss laut Hilfetext immer
Array-artig sein, und wir verwenden daher hier einfach eine Liste mit einem Element. <code class="docutils literal notranslate"><span class="pre">t_eval</span></code> enthält die
uns interessierenden Zeitpunkte, wobei im ersten Argument der <code class="xref py py-func docutils literal notranslate"><span class="pre">linspace()</span></code> der Stern bedeutet, dass
das Tupel <code class="docutils literal notranslate"><span class="pre">t_span</span></code> ausgepackt wird. Dies erspart es uns, explizit <code class="docutils literal notranslate"><span class="pre">t_span[0]</span></code> und <code class="docutils literal notranslate"><span class="pre">t_span[1]</span></code> anzugeben.
Das Argument <code class="docutils literal notranslate"><span class="pre">t_eval</span></code> können wir hier nicht über die Position übergeben, da sonst als viertes Argument
zunächst die Lösungsmethode angegeben werden müssen. Wir belassen es hier bei der defaultmäßig vorgesehenen
Runge-Kutta-Methode. Schließlich entnehmen wir dem Hilfetext, dass <code class="docutils literal notranslate"><span class="pre">sol</span></code> eine ganze Reihe von Informationen
über die Lösung enthält. Uns interessiert natürlich besonders die Lösung, die in <code class="docutils literal notranslate"><span class="pre">sol.y</span></code> enthalten ist.
Damit können wir nun die numerische Lösung graphisch darstellen und mit der analytischen Lösung vergleichen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">y_analytisch</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t_eval</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">y_analytisch</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/0b215d1157fba529768d9e5a823c35acd12cb51b990a93ed6eb0dae17504fa3b.png" src="_images/0b215d1157fba529768d9e5a823c35acd12cb51b990a93ed6eb0dae17504fa3b.png" />
</div>
</div>
<p>Da es schwierig ist, den Fehler der durch die blauen Punkte dargestellten numerischen Lösung im Vergleich
zur als orangefarbige Linie dargestellten analytischen Lösung mit bloßem Auge zu beurteilen, stellen wir
auch noch den relativen Fehler dar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">y_analytisch</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f8483080d7a0aca7fbdf981b961fc071811c18859bf00cafd8437956c98577ee.png" src="_images/f8483080d7a0aca7fbdf981b961fc071811c18859bf00cafd8437956c98577ee.png" />
</div>
</div>
<p>Aus der Abbildung lässt sich entnehmen, dass der relative Fehler hier immerhin bis zu 3‰ beträgt.</p>
<p>Auf den ersten Blick könnte man meinen, dass <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code> nur zur Lösung von Differentialgleichungen
erster Ordnung geeignet ist. Wie sieht es also zum Beispiel mit der Lösung der Bewegungsgleichung eines
gedämpften harmonischen Oszillators</p>
<div class="math notranslate nohighlight">
\[\ddot x + \alpha\dot x + x = 0\]</div>
<p>aus? Der Trick besteht darin, diese Differentialgleichung zweiter Ordnung durch Einführung der Geschwindigkeit
als Hilfsvariable in zwei Differentialgleichungen erster Ordnung umzuschreiben, womit wir ein System
gewöhnlicher Differentialgleichungen erster Ordnung</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\dot v &amp;= -x-\alpha v\\
\dot x &amp;= v
\end{align}\end{split}\]</div>
<p>erhalten. Dieses können wir mit Hilfe von <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code> lösen. Als Anfangsbedingungen wollen wir
<span class="math notranslate nohighlight">\(x(0) = 0, v(0) = 1\)</span> wählen, das gedämpfte Pendel also in der Ruhelage anstoßen. Natürlich hätten wir
eine kompliziertere Differentialgleichung wählen können, für die keine analytische Lösung zur Verfügung
steht. Wir wollen aber auch hier am Ende die numerische mit der analytischen Lösung vergleichen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ableitung</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">v</span><span class="p">]</span>

<span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">t_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">t_span</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">anfangsbedingungen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">ableitung</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">anfangsbedingungen</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span><span class="p">,))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/f63a9fe7dd8749f151f4fa030bb93e54f150de809e09829087d633fc7c7bad0e.png" src="_images/f63a9fe7dd8749f151f4fa030bb93e54f150de809e09829087d633fc7c7bad0e.png" />
</div>
</div>
<p>Im Gegensatz zum ersten Beispiel verlangt die Funktion, die wir hier <code class="docutils literal notranslate"><span class="pre">ableitung</span></code> genannt haben, neben
den Argumenten <code class="docutils literal notranslate"><span class="pre">t</span></code> und <code class="docutils literal notranslate"><span class="pre">y</span></code> noch den Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>. Dieser wird in einem Tupel an das Argument <code class="docutils literal notranslate"><span class="pre">args</span></code>
von <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code> übergeben. Die Lösung in <code class="docutils literal notranslate"><span class="pre">sol.y</span></code> ist ein Vektor, so dass wir bereits im ersten
Beispiel explizit <code class="docutils literal notranslate"><span class="pre">sol.y[0]</span></code> angeben mussten, um die Lösungsfunktion zu erhalten. Hier können wir nun
sowohl den Ort (blau dargestellt) als auch die Geschwindigkeit (orange dargestellt) als Komponenten
extrahieren.</p>
<p>Sehen wir uns abschließend noch die Differenz zur analytischen Lösung an.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">y_analytisch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.25</span><span class="o">*</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">omega</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">y_analytisch</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/6d1557fcb4e9cc8bec34b0ae0712e82a4a3e99a0fe7cc16c405315d9c65315a5.png" src="_images/6d1557fcb4e9cc8bec34b0ae0712e82a4a3e99a0fe7cc16c405315d9c65315a5.png" />
</div>
</div>
<p>Auch in diesem Fall erhalten wir einen Fehler von einigen Promille. Benötigt man eine genauere Lösung,
so kann die Parameter <code class="docutils literal notranslate"><span class="pre">atol</span></code> für den absoluten Fehler und <code class="docutils literal notranslate"><span class="pre">rtol</span></code> für den relativen Fehler entsprechend
anpassen. Weitere Informationen hierzu finden sich in obigem Hilfetext zu <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_ivp()</span></code>.</p>
<p>Zum Abschluss dieses Kapitels betonen wir noch einmal, dass wir hier nur einen
winzigen Eindruck von den vielfältigen Möglichkeiten geben konnten, die NumPy
und SciPy bieten. Es lohnt sich daher, einen Blick in die <a class="reference external" href="https://numpy.org/doc/stable/">Dokumentation von
NumPy</a> und die <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">Dokumentation von
SciPy</a> oder zumindest die
Überschriften der <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/#api-reference">API-Dokumentation von
SciPy</a> zu werfen.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="einausgabe.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">zurück</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Ein- und Ausgabe</p>
      </div>
    </a>
    <a class="right-next"
       href="objektorientiert.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">weiter</p>
        <p class="prev-next-title"><span class="section-number">9. </span>Objektorientiertes Programmieren</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Inhalt
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#installation">8.1. Installation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#arrays-und-anwendungen">8.2. Arrays und Anwendungen</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#numerische-integration">8.3. Numerische Integration</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#integration-gewohnlicher-differentialgleichungen">8.4. Integration gewöhnlicher Differentialgleichungen</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
Durch Gert-Ludwig Ingold
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright CC-BY.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>