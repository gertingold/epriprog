
<!DOCTYPE html>

<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. Einfache Datentypen, Variablen und Zuweisungen &#8212; Einführung in Prinzipien der Programmierung</title>
    
  <link rel="stylesheet" href="_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.2d2078699c18a0efb88233928e1cf6ed.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.be0a4a0c39cd630af62a2fcf693f3f06.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="4. Kontrollstrukturen" href="kontrollstrukturen.html" />
    <link rel="prev" title="2. Eine Vorschau" href="vorschau.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  
  <h1 class="site-logo" id="site-title">Einführung in Prinzipien der Programmierung</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Dieses Buch durchsuchen ..." aria-label="Dieses Buch durchsuchen ..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="einleitung.html">
   1. Einleitung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="vorschau.html">
   2. Eine Vorschau
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3. Einfache Datentypen, Variablen und Zuweisungen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kontrollstrukturen.html">
   4. Kontrollstrukturen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="funktionen.html">
   5. Funktionen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sequenzen.html">
   6. Zusammengesetzte Datentypen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="einausgabe.html">
   7. Ein- und Ausgabe
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="scipy.html">
   8. Numerische Programmbibliotheken am Beispiel von NumPy/SciPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="objektorientiert.html">
   9. Objektorientiertes Programmieren
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="grafik.html">
   10. Erstellung von Grafiken
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zahlensysteme.html">
   11. Anhang: Zahlensysteme
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="floats.html">
   12. Anhang: 64-Bit-Gleitkommazahlen nach IEEE-Standard 754
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="unicode.html">
   13. Anhang: Unicode
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Navigation umschalten" aria-controls="site-navigation"
            title="Navigation umschalten" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Laden Sie diese Seite herunter"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="_sources/datentypen.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Notebook-Datei herunterladen" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/datentypen.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Quelldatei herunterladen" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="In PDF drucken"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Vollbildmodus"
                title="Vollbildmodus"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/gertingold/epriprog/master?urlpath=tree/epriprog/datentypen.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Starten Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Inhalt
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ganze-zahlen">
   3.1. Ganze Zahlen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gleitkommazahlen">
   3.2. Gleitkommazahlen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#funktionen-fur-reelle-zahlen">
   3.3. Funktionen für reelle Zahlen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#komplexe-zahlen">
   3.4. Komplexe Zahlen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#variablen-und-zuweisungen">
   3.5. Variablen und Zuweisungen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#wahrheitswerte">
   3.6. Wahrheitswerte
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#formatierung-von-ausgaben">
   3.7. Formatierung von Ausgaben
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="einfache-datentypen-variablen-und-zuweisungen">
<span id="datentypen"></span><h1><span class="section-number">3. </span>Einfache Datentypen, Variablen und Zuweisungen<a class="headerlink" href="#einfache-datentypen-variablen-und-zuweisungen" title="Link zu dieser Überschrift">¶</a></h1>
<p>In <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> hatten wir bereits verschiedene Datentypen kennengelernt.
Hierzu gehören ganze Zahlen, die zum einen durch die explizite Umwandlung der
Benutzereingabe in eine ganze Zahl oder als Ergebnis der
<code class="xref py py-func docutils literal notranslate"><span class="pre">randrange()</span></code>-Funktion erzeugt wurden. Des Weiteren kamen Wahrheitswerte
vor. Ganz explizit war dies bei <code class="docutils literal notranslate"><span class="pre">True</span></code> der Fall, das zur Konstruktion einer
Dauerschleife verwendet wurde.</p>
<p>Diese beiden Datentypen, ganze Zahlen und Wahrheitswerte gehören zu den
einfachen Datentypen. Daneben gibt es auch zusammengesetzte Datentypen, für die
wir in <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> ebenfalls schon Beispiele gesehen hatten. Dazu
gehören die Zeichenketten, zum Beispiel in den Zeilen 12 bis 15 des
Beispielprogramms, aber auch die durch eckige Klammern
gekennzeichnete Liste in Zeile 11.</p>
<p>In diesem Kapitel werden wir uns zunächst den einfachen Datentypen zuwenden und
die zusammengesetzten Datentypen in einem späteren Kapitel besprechen. Dabei
werden wir vor allem neben den ganzen Zahlen noch weitere numerische Datentypen
kennenlernen, die für natur- und ingenieurwissenschaftliche Anwendungen große
Bedeutung besitzen.</p>
<div class="section" id="ganze-zahlen">
<span id="integers"></span><h2><span class="section-number">3.1. </span>Ganze Zahlen<a class="headerlink" href="#ganze-zahlen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Wir beginnen bei der Besprechung der numerischen Datentypen mit den ganzen
Zahlen, auf Englisch <em>integers</em>. Auf den ersten Blick könnte man denken, dass
in den Natur- und Ingenieurwissenschaften ganze Zahlen gegenüber den reellen
Zahlen eigentlich unwichtig sind. Auch wenn diese Einschätzung nicht ganz
falsch ist, verwenden wir auch in diesen Bereichen relativ oft ganze Zahlen,
zum Beispiel als Index für eine Vektor- oder Matrixkomponente. Beim
Programmieren spielen ganze Zahlen daher unter anderem eine große Rolle, sobald
etwas gezählt oder indiziert werden muss. Eine weitere Anwendung ganzer Zahlen
ergibt sich speziell in Python daraus, dass im Prinzip betragsmäßig beliebig
große ganze Zahlen dargestellt werden können. Dies ermöglicht es, Rechnungen
mit beliebiger Genauigkeit durchzuführen.</p>
<p>Die gerade angesprochene Frage, welche Zahlen überhaupt in einer Programmiersprache
dargestellt werden können, ist von großer Bedeutung. Es lohnt sich daher, sich
etwas genauer damit zu beschäftigen. Zahlen werden, wie andere Objekte auch, im
Computer intern immer mit Hilfe von Nullen und Einsen dargestellt. Begrenzt man
den Speicherplatz je Zahl, so ist der darstellbare Zahlenbereich eingeschränkt.
Daher werden wir im Folgenden statt von »ganzen Zahlen«, die wir für das mathematische
Objekt verwenden wollen, lieber von »Integers« sprechen, die sich auf die im
Computer realisierbaren Zahlen beziehen.</p>
<p>Die Frage nach den im Computer darstellbaren Zahlen ist insofern wichtig, als
ein Überschreiten des Zahlenbereichs zu Problemen führt. Bei den
Gleitkommazahlen, die wir im nächsten Kapitel besprechen werden, führt eine
begrenzte Zahl von Nachkommastellen zusätzlich zu dem Problem von
Rundungsfehlern.</p>
<p>Doch kommen wir zurück zu den Integers. Wenn Python im Prinzip betragsmäßig
beliebig große Zahlen erlaubt, könnte man meinen, dass man sich um die Größe
des Zahlenbereichs nicht weiter kümmern muss. Das ist allerdings nicht ganz
richtig.  Zum einen ist jeder reale Computerspeicher begrenzt, so dass der
Zahlenbereich letztlich doch eingeschränkt ist. In der Praxis spielt diese
Einschränkung kaum eine Rolle, sondern eher die Zeit, die eine Rechenoperation
mit sehr großen Integers benötigt. In anderen Programmiersprachen dagegen ist
der Bereich der möglichen Integers eingeschränkt. Da die für uns wichtigen
numerischen Programmbibliotheken NumPy und SciPy zu großen Teilen auf in C oder
Fortran geschriebenen Programmen basieren, werden dort auch unter Python die
Einschränkungen des Zahlenbereichs wichtig. Zu erwähnen wäre noch, dass die Integers,
die als Index zur Adressierung in Listen oder Zeichenketten verwendet werden
können, auch in Python beschränkt sind. Allerdings wird diese Beschränkung auf
modernen Computern selten ein Problem darstellen.</p>
<p>Wie ganze Zahlen im Computer dargestellt werden und was das für die
größenmäßige Einschränkung des Zahlenbereichs bedeutet, werden wir in einem
Anhang in <a class="reference internal" href="zahlensysteme.html#anhang-zahlensysteme"><span class="std std-numref">Kapitel 11</span></a> diskutieren.  Dort werden auch die
Grundlagen des Dualsystems erklärt, das der Darstellung von Zahlen mit Hilfe
von Nullen und Einsen zugrunde liegt. Hier wollen wir uns nun stärker der
praktischen Arbeit mit Integers zuwenden.</p>
<p>Als erstes wollen wir zeigen, dass Integers in Python tatsächlich sehr groß werden
können, indem wir die tausendste Potenz von 2 ausrechnen lassen. Der doppelte Stern
<code class="docutils literal notranslate"><span class="pre">**</span></code> steht dabei für den Exponentierungsoperator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="o">**</span><span class="mi">1000</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376
</pre></div>
</div>
</div>
</div>
<p>Das Ergebnis hat 302 Stellen. Genauso gut könnte man als Exponenten 100000 wählen
und würde dann ein Ergebnis mit 30103 Stellen erhalten.</p>
<p>Natürlich gibt es neben positiven Integers auch solche mit negativem Vorzeichen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="o">**</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="mi">101</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1267650600228229401496703205376
</pre></div>
</div>
</div>
</div>
<p>Die Leerzeichen um das Minuszeichen der Eingabe spielen für den Pythoninterpreter
keine Rolle, sondern dienen hier der besseren Lesbarkeit.</p>
<p>In Python kann man auch mit Dual-, Oktal- und Hexadezimalzahlen arbeiten. Eine
Einführung in Zahlensysteme, insbesondere das Dual- und das Hexadezimalsystem
wird in <a class="reference internal" href="zahlensysteme.html#anhang-zahlensysteme"><span class="std std-numref">Kapitel 11</span></a> gegeben. Um zwischen den verschiedenen
Zahlensystemen unterscheiden zu können, werden Präfixe verwendet, und zwar
<code class="docutils literal notranslate"><span class="pre">0b</span></code> oder <code class="docutils literal notranslate"><span class="pre">0B</span></code> für das Dualsystem, <code class="docutils literal notranslate"><span class="pre">0o</span></code> oder <code class="docutils literal notranslate"><span class="pre">0O</span></code> für das Oktalsystem
sowie <code class="docutils literal notranslate"><span class="pre">0x</span></code> oder <code class="docutils literal notranslate"><span class="pre">0X</span></code> für das Hexadezimalsystem. Die folgenden drei Darstellungen
sind jeweils äquivalent zur Zahl 25 im gewohnten Dezimalsystem</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mb">0b11001</span><span class="p">,</span> <span class="mo">0o31</span><span class="p">,</span> <span class="mh">0x19</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(25, 25, 25)
</pre></div>
</div>
</div>
</div>
<p>Die Umwandlung in das Binär-, Oktal- oder Hexadezimalformat erfolgt mit Hilfe der
Funktionen <code class="docutils literal notranslate"><span class="pre">bin</span></code>, <code class="docutils literal notranslate"><span class="pre">oct</span></code> bzw. <code class="docutils literal notranslate"><span class="pre">hex</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">bin</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="nb">oct</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="nb">hex</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&#39;0b11001&#39;, &#39;0o31&#39;, &#39;0x19&#39;)
</pre></div>
</div>
</div>
</div>
<p>Das Ergebnis ist allerdings keine Zahl, sondern eine Zeichenkette, wie an den
einschließenden Hochkommas zu erkennen ist.</p>
<p>Bei den meisten grundlegenden mathematischen Operationen wie Addition, Subtraktion,
Multiplikation und Exponentiation ist gewährleistet, dass bei der Anwendung auf
ganze Zahlen das Ergebnis wieder eine ganze Zahl ist. Eine Ausnahme ist die Division,
da nicht klar ist, dass sich der Dividend durch den Divisor ohne Rest teilen lässt.</p>
<p>Um fehlerhafte Programme zu vermeiden, ist es daher wichtig zu wissen, wie die
verwendete Programmiersprache die Division handhabt. Prinzipiell gibt es zwei
Möglichkeiten. Eine Möglichkeit besteht darin, bei der Division von zwei ganzen
Zahlen wieder eine ganze Zahl zu erzeugen und einen eventuell entstehenden Rest
zu ignorieren. Bei der anderen Möglichkeit wird der Quotient als Gleitkommazahl
dargestellt. Keine der beiden Varianten ist besser als die andere, so dass es für
eine Programmiersprache auch keine natürliche Wahl gibt. Tatsächlich hat sich
Python in der Version 2 an dieser Stelle anders verhalten als die Version 3, die
wir heute benutzen.</p>
<p>Sehen wir uns an, wie Python 3 mit der Division von zwei Integers umgeht.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">15</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.0
</pre></div>
</div>
</div>
</div>
<p>Offenbar wird hier immer eine Gleitkommazahl erzeugt, was an dem Dezimalpunkt
ersichtlich ist. Dies gilt auch, wenn der Quotient wie im zweiten Fall im
Prinzip als ganze Zahl darstellbar wäre.</p>
<p>Gelegentlich benötigt man aber eine Ganzzahldivision. In Python 3 erhält man diese
mit einem doppelten Schrägstrich.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">//</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">15</span><span class="o">//</span><span class="mi">7</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mi">15</span><span class="o">//</span><span class="mi">7</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-3
</pre></div>
</div>
</div>
</div>
<div class="admonition-frage admonition">
<p class="admonition-title">Frage</p>
<p>Was macht der <code class="docutils literal notranslate"><span class="pre">//</span></code>-Divisionsoperator in Python 3 tatsächlich, vor allem vor dem
Hintergrund des letzten Beispiels? Warum dies so ist, lässt sich in einem
<a class="reference external" href="http://python-history.blogspot.de/2010/08/why-pythons-integer-division-floors.html">Blog-Artikel</a>
von Guido van Rossum nachlesen.</p>
</div>
<p>Um zu verdeutlichen, dass die in Python 3 getroffene Wahl nicht zwingend ist,
sehen wir uns zum Vergleich die Division in der Programmiersprache C an.
Hier liefert</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">15</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">-15</span><span class="o">/</span><span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>als Ergebnis</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">-</span><span class="mi">2</span>
</pre></div>
</div>
<p>Im Gegensatz zu Python 3 führt in C die Division zweier Integers wieder auf einen
Integer. Zudem wird hier zur Null hin abgeschnitten. Im zweiten Fall ergibt sich also
nicht -3 wie bei Python 3, sondern -2. Genauso verhält sich auch der entsprechende
Fortran-Code</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">division</span>
  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="mi">15</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">15</span><span class="o">/</span><span class="mi">7</span>
  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span>
<span class="k">end program </span><span class="n">division</span>
</pre></div>
</div>
<p>mit dem Ergebnis</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>           <span class="mi">2</span>          <span class="o">-</span><span class="mi">2</span>
           <span class="mi">0</span>  <span class="mf">0.500000000</span>
</pre></div>
</div>
<p>Die zweite Ausgabezeile illustriert, dass man hier eine Gleitkommadivision
erzwingen kann, indem man mindestens eine der beiden Zahlen zu einer Gleitkommazahl
macht.</p>
<p>Kommen wir nach diesem Ausflug zu anderen Programmiersprachen wieder zurück zu
Python. Oft ist man am Rest einer Integerdivision interessiert. Diesen könnte man
im Prinzip folgendermaßen erhalten</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zaehler</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">nenner</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">rest</span> <span class="o">=</span> <span class="n">zaehler</span> <span class="o">-</span> <span class="p">(</span><span class="n">zaehler</span><span class="o">//</span><span class="n">nenner</span><span class="p">)</span><span class="o">*</span><span class="n">nenner</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>Mit Hilfe des Modulo-Operators <code class="docutils literal notranslate"><span class="pre">%</span></code> von Python geht dies jedoch einfacher.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zaehler</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">nenner</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">zaehler</span> <span class="o">%</span> <span class="n">nenner</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>Eine häufige Anwendung ist der Test auf eine gerade oder ungerade Zahl.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">16</span> <span class="o">%</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0
</pre></div>
</div>
</div>
</div>
<p>Ist die Zahl ohne Rest durch 2 teilbar, ist sie offenbar gerade, ansonsten ungerade.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">17</span> <span class="o">%</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<p>Benötigt man sowohl den Quotienten als auch den Rest, so kann man in Python beides
in einem Schritt mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code>-Funktion erhalten</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quotient</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">quotient</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8 2
</pre></div>
</div>
</div>
</div>
<p>Ein weiterer wichtiger Punkt, der hier für Integers zum ersten Mal auftritt, aber
viel weitreichendere Bedeutung hat, ist die Reihenfolge, in der Operationen
ausgeführt werden. In dem folgenden Beispiel sehen wir, dass in Python ebenso wie
in C und Fortran die Regel Punkt vor Strich gilt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>14
</pre></div>
</div>
</div>
</div>
<p>Der Ausdruck wird also nicht von links nach rechts abgearbeitet. Möchte man zuerst
die Addition ausführen, so muss man Klammern setzen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>20
</pre></div>
</div>
</div>
</div>
<p>Die wichtigsten für Python geltenden Vorrangregeln sind in der <a class="reference internal" href="#table-precedence"><span class="std std-numref">Tab. 3.1</span></a>
dargestellt. Dabei haben die weiter oben stehenden Operationen Vorrang vor den nachfolgenden
Operationen [^precedence].</p>
<table class="table" id="table-precedence">
<caption><span class="caption-number">Tab. 3.1 </span><span class="caption-text">Die weiter oben in der Liste stehenden Operationen haben Vorrang vor den weiter unten stehenden. Eine vollständige Liste findet man unter dem Punkt <a class="reference external" href="http://docs.python.org/3/reference/expressions.html#operator-precedence">Operator precedence</a> in der Python-Dokumentation. Beachten Sie, dass die dortige Tabelle umgekehrt geordnet ist, also weiter unten stehende Operatoren Vorrang haben.</span><a class="headerlink" href="#table-precedence" title="Link zu dieser Tabelle">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operatoren</p></th>
<th class="head"><p>Beschreibung</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>**</p></td>
<td><p>Exponentiation</p></td>
</tr>
<tr class="row-odd"><td><p>+x, -x</p></td>
<td><p>Positives und negatives Vorzeichen</p></td>
</tr>
<tr class="row-even"><td><p>*, /, //, %</p></td>
<td><p>Multiplikation, Division, Modulo</p></td>
</tr>
<tr class="row-odd"><td><p>+, -</p></td>
<td><p>Addition, Subtraktion</p></td>
</tr>
</tbody>
</table>
<p>Wird der Exponentierungsoperator <code class="docutils literal notranslate"><span class="pre">**</span></code> direkt von einem Plus oder Minus
gefolgt, bindet das Vorzeichen allerdings stärker, was ja auch die einzig
sinnvolle Interpretation dieses Codes ist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span><span class="o">**-</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.25
</pre></div>
</div>
</div>
</div>
<p>Dagegen ist das Ergebnis von</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-4
</pre></div>
</div>
</div>
</div>
<p>negativ.</p>
<p>Stehen Operatoren auf der gleichen Stufe, so wird der Ausdruck von links nach
rechts ausgewertet. Gegebenenfalls müssen Klammern verwendet werden, um die
gewünschte Reihenfolge sicherzustellen. Es spricht auch nichts dagegen, im
Zweifelsfall oder zur besseren Lesbarkeit Klammern zu setzen, selbst wenn diese
nicht zur korrekten Abarbeitung des Ausdrucks erforderlich sind.</p>
<div class="admonition-frage admonition">
<p class="admonition-title">Frage</p>
<p>Was ergibt <code class="docutils literal notranslate"><span class="pre">-2*4+3**2</span></code>? Was ergibt <code class="docutils literal notranslate"><span class="pre">6**4//2</span></code>?</p>
</div>
</div>
<div class="section" id="gleitkommazahlen">
<span id="float"></span><h2><span class="section-number">3.2. </span>Gleitkommazahlen<a class="headerlink" href="#gleitkommazahlen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Eine zentrale Rolle in der wissenschaftlichen Numerik spielen Gleitkommazahlen,
die häufig auch mit dem englischen Begriff als <em>Floats</em> bezeichnet werden.
Wir werden diesen Begriff gelegentlich verwenden, insbesondere um den Unterschied
zum mathematischen Begriff der reellen Zahlen deutlich zu machen. Wesentlich ist
dabei, dass sowohl der Zahlenbereich der Floats als auch die Zahl der
Nachkommastellen begrenzt sind.</p>
<p>Während man sich beim normalen Rechnen per Hand üblicherweise keine
Rechenschaft darüber ablegen muss, ob eine Zahl eine ganze Zahl oder eine
Gleitkommazahl ist, ist dies beim numerischen Arbeiten anders. Im <a class="reference internal" href="#integers"><span class="std std-numref">Kapitel 3.1</span></a>
hatten wir ja schon gesehen, dass der Datentyp bei der Division durchaus eine Rolle
spielen kann.</p>
<p>An dieser Stelle müssen wir wieder einmal auf Unterschiede zwischen Programmiersprachen
hinweisen. In Sprachen wie C und Fortran muss der Datentyp einer Variable festgelegt
werden. Das Fortranprogramm</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">datentyp</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">n</span>
  <span class="kt">real</span><span class="kd">::</span> <span class="n">x</span>

  <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="hll">  <span class="n">x</span> <span class="o">=</span> <span class="n">n</span>
</span>  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span>
<span class="k">end program </span><span class="n">datentyp</span>
</pre></div>
</div>
<p>erzeugt die Ausgabe</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>           <span class="mi">2</span>   <span class="mf">2.00000000</span>
</pre></div>
</div>
<p>Gemäß der Deklaration zu Beginn des Programms handelt es sich bei der Variable <code class="docutils literal notranslate"><span class="pre">n</span></code> um
einen Integer, während <code class="docutils literal notranslate"><span class="pre">x</span></code> ein Float ist, der in Fortran mit <code class="docutils literal notranslate"><span class="pre">real</span></code> bezeichnet wird. In
der hervorgehobenen Zeile findet bei der Zuweisung automatisch die Umwandlung zwischen
den beiden Datentypen statt.</p>
<p>Im Gegensatz dazu ist eine Festlegung des Datentyps in Python nicht erforderlich.
Man spricht in diesem Zusammenhang auch von <em>duck typing</em>: »If it looks like a
duck and quacks like a duck, it must be a duck.« Kritiker halten dem entgegen, dass
sich auch ein Drache scheinbar wie eine Ente verhalten kann.</p>
<p>Den Typ einer Variable kann man in Python mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code>-Funktion herausfinden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;int&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Eine Umwandlung von einem Integer zu einem Float lässt sich in Python mit Hilfe der
<code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code>-Funktion vornehmen, wobei wir in diesem Beispiel gleich überprüfen, ob
die Umwandlung tatsächlich stattgefunden hat.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;float&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Die umgekehrte Umwandlung von Floats in Integers ist mit der <code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code>-Funktion
möglich, wobei der Nachkommaanteil einfach abgeschnitten wird:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span><span class="p">(</span><span class="mf">2.7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Bereits das Anhängen eines Punktes genügt, damit Python die Zahl als Float
interpretiert:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="mf">2.</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;float&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Für Floats gibt es zwei mögliche Schreibweisen. Zum einen die kann man die
Dezimalbruchschreibweise verwenden, bei der ein Dezimalpunkt erwartet wird.
Stehen vor oder nach dem Dezimalpunkt keine Ziffern, so wird der entsprechende
Anteil gleich Null gesetzt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">5.</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="mi">25</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.25
</pre></div>
</div>
</div>
</div>
<p>Es ist aber nicht möglich, im Sinne einer abkürzenden Schreibweise sowohl vor
als auch nach dem Dezimalpunkt auf Ziffern zu verzichten.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">.</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-25-a5d5b61aa8a6&gt;&quot;</span><span class="gt">, line </span><span class="mi">1</span>
    <span class="o">.</span>
    <span class="o">^</span>
<span class="ne">SyntaxError</span>: invalid syntax
</pre></div>
</div>
</div>
</div>
<p>Für sehr kleine oder sehr große Zahlen ist die Exponentialschreibweise besser
geeignet. Die Zahl wird dabei mit Hilfe einer Mantisse, die nicht zwingend
einen Dezimalpunkt enthalten muss, und einem ganzzahligen Exponenten, der ein
Vorzeichen enthalten darf, dargestellt.  Zwischen Mantisse und Exponenten muss
dabei ein <code class="docutils literal notranslate"><span class="pre">e</span></code> oder ein <code class="docutils literal notranslate"><span class="pre">E</span></code> stehen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1e-2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.01
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1.53e2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>153.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1E-5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1e-05
</pre></div>
</div>
</div>
</div>
<p>Da Dezimalzahlen im Allgemeinen keine endliche Binärdarstellung besitzen, kann
es bei der Umwandlung in die Binärdarstellung zu Rundungsfehlern kommen.
In <a class="reference internal" href="zahlensysteme.html#dualsystem"><span class="std std-numref">Kapitel 11.1</span></a> wurde festgestellt, dass <span class="math notranslate nohighlight">\(0{,}1_{10} = 0{,}0\overline{0011}_2\)</span>,
so dass diese Zahl im Dualsystem auf jeden Fall abgeschnitten werden muss.
Das Problem wird an dem folgenden Beispiel deutlich, das zudem zeigt, dass es
auf die Reihenfolge der Operationen ankommen kann.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.551115123125783e-17
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.3</span><span class="o">+</span><span class="mf">0.1</span><span class="o">+</span><span class="mf">0.1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7755575615628914e-17
</pre></div>
</div>
</div>
</div>
<p>Für die praktische Arbeit ist es wichtig, ein Gefühl dafür zu entwickeln, ob
zum Beispiel eine von Null verschiedene Zahl ein wichtiger Effekt ist oder lediglich
die Folge eines Rundungsfehlers.</p>
<p>Wie bereits gesagt, sind Floats in ihrer Größe begrenzt und sie können auch
nicht beliebig dicht liegen. Informationen hierzu lassen sich in Python abfragen.
Die größtmögliche Zahl, die sich als Float darstellen lässt lautet</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.7976931348623157e+308
</pre></div>
</div>
</div>
</div>
<p>Die Distanz zwischen der 1 und der nächsten darauf folgenden darstellbaren Zahl ist</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.220446049250313e-16
</pre></div>
</div>
</div>
</div>
<p>Die kleinste normalisierte Zahl ist</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.2250738585072014e-308
</pre></div>
</div>
</div>
</div>
<p>aber tatsächlich ist die kleinste darstellbare Zahl gleich <code class="docutils literal notranslate"><span class="pre">5e-324</span></code>. Es gibt also
um die Null herum eine Lücke, die jedoch deutlich kleiner ist als die Lücke zwischen
der Eins und der darauf folgenden Zahl.</p>
<div class="tip admonition">
<p class="admonition-title">Hinweis</p>
<p>Seit Python 3.9 lässt sich die kleinste darstellbare Zahl, also <code class="docutils literal notranslate"><span class="pre">5e-324</span></code>
mit Hilfe von <code class="docutils literal notranslate"><span class="pre">math.ulp(0)</span></code> erhalten.</p>
</div>
<p>Der Zahlenbereich für Floats sowie die Lücken um die Null und die Eins ergeben
sich aus dem verwendeten Zahlenformat, das im IEEE-Standard 754 definiert ist.
Einige Informationen dazu finden sich in <a class="reference internal" href="floats.html#anhang-floats"><span class="std std-numref">Kapitel 12</span></a>.</p>
<p>Im Gegensatz zu Integers können Gleitkommazahlen also nicht beliebig groß
werden, sondern sind auf einen allerdings recht großzügig bemessenen Bereich
bis etwas über <span class="math notranslate nohighlight">\(10^{308}\)</span> beschränkt. Sollte dieser Bereich sich als
nicht ausreichend herausstellen, ist es empfehlenswert, sich zunächst einmal
Gedanken darüber zu machen, ob man das verwendete numerische Verfahren geeignet
formuliert hat. Eventuell kann schon eine Skalierung der Variablen das Problem
beseitigen. Im schlimmsten Fall kann man in Python zum
<a class="reference external" href="http://mpmath.org/doc/current/"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mpmath</span></code>-Modul</a> greifen, das es erlaubt,
mit mehr als den standardmäßigen 15 signifikanten Stellen zu rechnen.</p>
<p>Was passiert aber, wenn man den zulässigen Zahlenbereich von Floats überschreitet?
In diesem Fall setzt Python die entsprechende Zahl auf Unendlich oder <code class="docutils literal notranslate"><span class="pre">inf</span></code> vom
vom englischen <em>infinity</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="o">*</span><span class="mf">1.00000001</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>inf
</pre></div>
</div>
</div>
</div>
<p>Dieses Unendlich ist zudem vorzeichenbehaftet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="o">*</span><span class="mf">1.00000001</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-inf
</pre></div>
</div>
</div>
</div>
<p>In manchen Situation kann man mit dem Ergebnis sogar noch weiterrechnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="o">*</span><span class="mf">1.00000001</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0
</pre></div>
</div>
</div>
</div>
<p>Dies ist jedoch nicht der Fall, wenn man zweimal positiv Unendlich voneinander abziehen will.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1e400</span> <span class="o">-</span> <span class="mf">1e401</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>nan
</pre></div>
</div>
</div>
</div>
<p>Hierbei steht <code class="docutils literal notranslate"><span class="pre">nan</span></code> für »not a number«.</p>
<p>Anders als man nach dieser Diskussion vielleicht denke könnte, hat eine Division durch Null
nicht das Ergebnis <code class="docutils literal notranslate"><span class="pre">inf</span></code>. Vielmehr gibt es einen <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mf">1.5</span><span class="o">/</span><span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ZeroDivisionError</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">38</span><span class="o">-</span><span class="n">aab2144c050b</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="mf">1.5</span><span class="o">/</span><span class="mi">0</span>

<span class="ne">ZeroDivisionError</span>: float division by zero
</pre></div>
</div>
</div>
</div>
<p>Hierbei handelt es sich um eine so genannte Ausnahme oder Englisch <em>exception</em>, die man geeignet
behandeln kann, wie wir später noch sehen werden.</p>
</div>
<div class="section" id="funktionen-fur-reelle-zahlen">
<span id="mathfunc"></span><h2><span class="section-number">3.3. </span>Funktionen für reelle Zahlen<a class="headerlink" href="#funktionen-fur-reelle-zahlen" title="Link zu dieser Überschrift">¶</a></h2>
<p>In numerischen Anwendungen in den Natur- und Ingenieurwissenschaften wird man häufig
mathematische Funktionen auswerten wollen. Der Versuch, beispielsweise eine
Exponentialfunktion auszuwerten, führt jedoch nicht unmittelbar zum Erfolg.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">39</span><span class="o">-</span><span class="mi">840</span><span class="n">a487878a2</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="ne">NameError</span>: name &#39;exp&#39; is not defined
</pre></div>
</div>
</div>
</div>
<p>Hierfür kann es im Wesentlichen zwei Gründe geben. Entweder hat die Exponentialfunktion
nicht den Namen <code class="docutils literal notranslate"><span class="pre">exp</span></code> oder die Exponentialfunktion ist nicht verfügbar, zumindest nicht
so unmittelbar, wie wir das hier annehmen. Tatsächlich muss man in Python, genauso wie
in C, ein klein wenig mehr tun, als nur die Exponentialfunktion aufzurufen.</p>
<p>Bevor wir uns das gleich genauer ansehen, wollen wir kurz auf zwei für das
wissenschaftliche Rechnen relevante Programmiersprachen hinweisen, bei denen
die Exponentialfunktion sowie eine ganze Reihe weiterer mathematischer
Funktionen direkt aufgerufen werden können. Eine dieser Sprachen ist Fortran,
eine relativ alte, aber im wissenschaftlichen Bereich immer noch häufig
eingesetzte Sprache, deren Name ursprünglich als Abkürzung für »Formula
Translation« stand. Damit kann man schon erwarten, dass sich iin Fortran
mathematische Funktionen sehr einfach verwenden lassen.</p>
<p>Eine moderne Sprache, in der dies ebenfalls der Fall ist, ist Julia.
Hierbei handelt es sich wie bei Python um eine interpretierte Sprache, so
dass wir die Exponentiation einfach in der Julia-Shell ausprobieren können.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="o">$</span> <span class="n">julia</span>
               <span class="n">_</span>
   <span class="n">_</span>       <span class="n">_</span> <span class="n">_</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="n">_</span>     <span class="o">|</span>  <span class="n">Documentation</span><span class="o">:</span> <span class="n">https</span><span class="o">://</span><span class="n">docs</span><span class="o">.</span><span class="n">julialang</span><span class="o">.</span><span class="n">org</span>
  <span class="p">(</span><span class="n">_</span><span class="p">)</span>     <span class="o">|</span> <span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">(</span><span class="n">_</span><span class="p">)</span>    <span class="o">|</span>
   <span class="n">_</span> <span class="n">_</span>   <span class="n">_</span><span class="o">|</span> <span class="o">|</span><span class="n">_</span>  <span class="n">__</span> <span class="n">_</span>   <span class="o">|</span>  <span class="kt">Type</span> <span class="s">&quot;?&quot;</span> <span class="k">for</span> <span class="n">help</span><span class="p">,</span> <span class="s">&quot;]?&quot;</span> <span class="k">for</span> <span class="n">Pkg</span> <span class="n">help</span><span class="o">.</span>
  <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|/</span> <span class="n">_</span><span class="sb">` |  |</span>
<span class="sb">  | | |_| | | | (_| |  |  Version 1.5.2 (2020-09-23)</span>
<span class="sb"> _/ |\__&#39;_|_|_|\__&#39;_|  |  Official https://julialang.org/ release</span>
<span class="sb">|__/                   |</span>

<span class="sb">julia&gt; exp(2)</span>
<span class="sb">7.38905609893065</span>
</pre></div>
</div>
<p>Wesentlich komplizierter ist das Vorgehen in Python allerdings auch nicht. Man
muss nur daran denken, zunächst das Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>, das Bestandteil der
Python-Standardbibliothek ist zu laden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>7.38905609893065
</pre></div>
</div>
</div>
</div>
<p>Zum Vergleich mit Python betrachten wir den folgenden Code, der die Verwendung
einer mathematischen Funktion in der Programmiersprache C illustriert:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="hll"><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Die Exponentialfunktion von %f ist %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Hier entspricht die hervorgehobene Zeile dem <code class="docutils literal notranslate"><span class="pre">import</span></code>-Befehl in Python. Zudem muss
man beim Kompilieren, also der Übersetzung des Programms in maschinenlesbaren Code
mit <code class="docutils literal notranslate"><span class="pre">-lm</span></code> noch die Mathematikbibliothek hinzuzulinken.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ cc -o bsp_exp bsp_exp.c -lm
$ ./bsp_exp
Die Exponentialfunktion von <span class="m">2</span>.000000 ist <span class="m">7</span>.389056
</pre></div>
</div>
<p>In der ersten Zeile wird mit <code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">bsp_exp</span></code> festgelegt, dass die Ausgabedatei
den Namen <code class="docutils literal notranslate"><span class="pre">bsp_exp</span></code> heißen soll. Diese wird in der zweiten Zeile ausgeführt
und wir erhalten in der dritten Zeile die erwartete Ausgabe.</p>
<div class="toggle admonition">
<p class="admonition-title">Weiterführendes (rechts aufklappen)</p>
<p>Nach der Kompilierung des obigen C-Programms entsteht als Zwischenprodukt
ein so genanntes Assembler-Programm, das schon sehr maschinennah ist und
von einem Assembler in den von einem Computer les- und ausführbaren
Maschinencode umgewandelt wird.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>            .file   &quot;bsp_exp.c&quot;
            .text
            .section        .rodata
            .align 8
    .LC1:
            .string &quot;Die Exponentialfunktion von %f ist %f\n&quot;
            .text
            .globl  main
            .type   main, @function
    main:
    .LFB0:
            .cfi_startproc
            pushq   %rbp
            .cfi_def_cfa_offset 16
            .cfi_offset 6, -16
            movq    %rsp, %rbp
            .cfi_def_cfa_register 6
            subq    $32, %rsp
            movsd   .LC0(%rip), %xmm0
            movsd   %xmm0, -8(%rbp)
            movq    -8(%rbp), %rax
            movq    %rax, -24(%rbp)
            movsd   -24(%rbp), %xmm0
            call    exp@PLT
            movq    -8(%rbp), %rax
            movapd  %xmm0, %xmm1
            movq    %rax, -24(%rbp)
            movsd   -24(%rbp), %xmm0
            leaq    .LC1(%rip), %rdi
            movl    $2, %eax
            call    printf@PLT
            movl    $0, %eax
            leave
            .cfi_def_cfa 7, 8
            ret
            .cfi_endproc
    .LFE0:
            .size   main, .-main
            .section        .rodata
            .align 8
    .LC0:
            .long   0
            .long   1073741824
            .ident  &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;
            .section        .note.GNU-stack,&quot;&quot;,@progbits
</pre></div>
</div>
</div>
<p>Kommen wir nach diesem Ausflug in andere Programmiersprachen zurück zum Import von
Funktionen aus dem <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul der Python-Standardbibliothek. Die obige Form
des Imports ist nur eine von mehrere möglichen Varianten, die Vor- und Nachteile haben.</p>
<p>In der ersten Variante, die wir weiter oben verwendet haben, wird das Modul, hier <code class="docutils literal notranslate"><span class="pre">math</span></code>
dem eigenen Code bekannt gemacht. Dies geschieht in unserem Beispiel mit <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">math</span></code>.
Der Nachteil hiervon ist, dass man jedes Mal, wenn man sich auf ein Objekt aus dem Modul
beziehen will, den Modulnamen voranstellen muss. Deswegen mussten wir <code class="docutils literal notranslate"><span class="pre">math.exp</span></code> schreiben.
Diese Mehrarbeit lohnt sich aber unter Umständen, um im Code deutlich zu machen, aus
welchem Modul zum Beispiel eine Funktion stammt.</p>
<p>Alternativ hierzu kann man bestimmte Objekte, also Funktionen oder auch Attribute,
importieren. Diese stehen dann wie in dem folgenden Beispiel zur Verfügung, ohne dass
der Modulname voranzustellen ist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0
</pre></div>
</div>
</div>
</div>
<p>Schließlich gibt es noch die Möglichkeit,  sämtliche Objekte eines Moduls auf einmal
einbinden</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.302585092994046
</pre></div>
</div>
</div>
</div>
<p>Dieses Vorgehen ist allerdings nicht ganz unproblematisch, da man auf diese
Weise einen unter Umständen großen Namensraum einbindet und damit potentiell
unabsichtlich Funktionen definiert oder umdefiniert, wodurch die Funktion
des Programms beeinträchtigt werden kann. Einer solchen Situation werden wir im nächsten
Abschnitt noch begegnen.</p>
<p>Jetzt wollen wir uns aber zunächst einen Überblick über die Funktionalität verschaffen,
die uns das <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul zur Verfügung stellt. Nachdem wir das Modul schon weiter
oben importiert haben, können wir uns eine Hilfetext ausgeben lassen, der alle definierten
Funktionen und Konstanten zusammen mit einem erläuternden Text aufführt. Wir werden im Folgenden
einige Aspekte diskutieren. Zuvor können Sie sich aber gerne anhand des Hilfetextes einen
ersten Überblick über die Möglichkeiten verschaffen, die das <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul bietet.
Beachten Sie dabei, dass das Modul im Laufe der Zeit weiterentwickelt wird. Es kann also sein,
dass einzelne Funktionen in älteren Python-Versionen noch nicht vorhanden sind.</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">math</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on module math:

NAME
    math

MODULE REFERENCE
    https://docs.python.org/3.8/library/math
    
    The following documentation is automatically generated from the Python
    source files.  It may be incomplete, incorrect or include features that
    are considered implementation detail and may vary between Python
    implementations.  When in doubt, consult the module reference at the
    location listed above.

DESCRIPTION
    This module provides access to the mathematical functions
    defined by the C standard.

FUNCTIONS
    acos(x, /)
        Return the arc cosine (measured in radians) of x.
    
    acosh(x, /)
        Return the inverse hyperbolic cosine of x.
    
    asin(x, /)
        Return the arc sine (measured in radians) of x.
    
    asinh(x, /)
        Return the inverse hyperbolic sine of x.
    
    atan(x, /)
        Return the arc tangent (measured in radians) of x.
    
    atan2(y, x, /)
        Return the arc tangent (measured in radians) of y/x.
        
        Unlike atan(y/x), the signs of both x and y are considered.
    
    atanh(x, /)
        Return the inverse hyperbolic tangent of x.
    
    ceil(x, /)
        Return the ceiling of x as an Integral.
        
        This is the smallest integer &gt;= x.
    
    comb(n, k, /)
        Number of ways to choose k items from n items without repetition and without order.
        
        Evaluates to n! / (k! * (n - k)!) when k &lt;= n and evaluates
        to zero when k &gt; n.
        
        Also called the binomial coefficient because it is equivalent
        to the coefficient of k-th term in polynomial expansion of the
        expression (1 + x)**n.
        
        Raises TypeError if either of the arguments are not integers.
        Raises ValueError if either of the arguments are negative.
    
    copysign(x, y, /)
        Return a float with the magnitude (absolute value) of x but the sign of y.
        
        On platforms that support signed zeros, copysign(1.0, -0.0)
        returns -1.0.
    
    cos(x, /)
        Return the cosine of x (measured in radians).
    
    cosh(x, /)
        Return the hyperbolic cosine of x.
    
    degrees(x, /)
        Convert angle x from radians to degrees.
    
    dist(p, q, /)
        Return the Euclidean distance between two points p and q.
        
        The points should be specified as sequences (or iterables) of
        coordinates.  Both inputs must have the same dimension.
        
        Roughly equivalent to:
            sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))
    
    erf(x, /)
        Error function at x.
    
    erfc(x, /)
        Complementary error function at x.
    
    exp(x, /)
        Return e raised to the power of x.
    
    expm1(x, /)
        Return exp(x)-1.
        
        This function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.
    
    fabs(x, /)
        Return the absolute value of the float x.
    
    factorial(x, /)
        Find x!.
        
        Raise a ValueError if x is negative or non-integral.
    
    floor(x, /)
        Return the floor of x as an Integral.
        
        This is the largest integer &lt;= x.
    
    fmod(x, y, /)
        Return fmod(x, y), according to platform C.
        
        x % y may differ.
    
    frexp(x, /)
        Return the mantissa and exponent of x, as pair (m, e).
        
        m is a float and e is an int, such that x = m * 2.**e.
        If x is 0, m and e are both 0.  Else 0.5 &lt;= abs(m) &lt; 1.0.
    
    fsum(seq, /)
        Return an accurate floating point sum of values in the iterable seq.
        
        Assumes IEEE-754 floating point arithmetic.
    
    gamma(x, /)
        Gamma function at x.
    
    gcd(x, y, /)
        greatest common divisor of x and y
    
    hypot(...)
        hypot(*coordinates) -&gt; value
        
        Multidimensional Euclidean distance from the origin to a point.
        
        Roughly equivalent to:
            sqrt(sum(x**2 for x in coordinates))
        
        For a two dimensional point (x, y), gives the hypotenuse
        using the Pythagorean theorem:  sqrt(x*x + y*y).
        
        For example, the hypotenuse of a 3/4/5 right triangle is:
        
            &gt;&gt;&gt; hypot(3.0, 4.0)
            5.0
    
    isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)
        Determine whether two floating point numbers are close in value.
        
          rel_tol
            maximum difference for being considered &quot;close&quot;, relative to the
            magnitude of the input values
          abs_tol
            maximum difference for being considered &quot;close&quot;, regardless of the
            magnitude of the input values
        
        Return True if a is close in value to b, and False otherwise.
        
        For the values to be considered close, the difference between them
        must be smaller than at least one of the tolerances.
        
        -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
        is, NaN is not close to anything, even itself.  inf and -inf are
        only close to themselves.
    
    isfinite(x, /)
        Return True if x is neither an infinity nor a NaN, and False otherwise.
    
    isinf(x, /)
        Return True if x is a positive or negative infinity, and False otherwise.
    
    isnan(x, /)
        Return True if x is a NaN (not a number), and False otherwise.
    
    isqrt(n, /)
        Return the integer part of the square root of the input.
    
    ldexp(x, i, /)
        Return x * (2**i).
        
        This is essentially the inverse of frexp().
    
    lgamma(x, /)
        Natural logarithm of absolute value of Gamma function at x.
    
    log(...)
        log(x, [base=math.e])
        Return the logarithm of x to the given base.
        
        If the base not specified, returns the natural logarithm (base e) of x.
    
    log10(x, /)
        Return the base 10 logarithm of x.
    
    log1p(x, /)
        Return the natural logarithm of 1+x (base e).
        
        The result is computed in a way which is accurate for x near zero.
    
    log2(x, /)
        Return the base 2 logarithm of x.
    
    modf(x, /)
        Return the fractional and integer parts of x.
        
        Both results carry the sign of x and are floats.
    
    perm(n, k=None, /)
        Number of ways to choose k items from n items without repetition and with order.
        
        Evaluates to n! / (n - k)! when k &lt;= n and evaluates
        to zero when k &gt; n.
        
        If k is not specified or is None, then k defaults to n
        and the function returns n!.
        
        Raises TypeError if either of the arguments are not integers.
        Raises ValueError if either of the arguments are negative.
    
    pow(x, y, /)
        Return x**y (x to the power of y).
    
    prod(iterable, /, *, start=1)
        Calculate the product of all the elements in the input iterable.
        
        The default start value for the product is 1.
        
        When the iterable is empty, return the start value.  This function is
        intended specifically for use with numeric values and may reject
        non-numeric types.
    
    radians(x, /)
        Convert angle x from degrees to radians.
    
    remainder(x, y, /)
        Difference between x and the closest integer multiple of y.
        
        Return x - n*y where n*y is the closest integer multiple of y.
        In the case where x is exactly halfway between two multiples of
        y, the nearest even value of n is used. The result is always exact.
    
    sin(x, /)
        Return the sine of x (measured in radians).
    
    sinh(x, /)
        Return the hyperbolic sine of x.
    
    sqrt(x, /)
        Return the square root of x.
    
    tan(x, /)
        Return the tangent of x (measured in radians).
    
    tanh(x, /)
        Return the hyperbolic tangent of x.
    
    trunc(x, /)
        Truncates the Real x to the nearest Integral toward 0.
        
        Uses the __trunc__ magic method.

DATA
    e = 2.718281828459045
    inf = inf
    nan = nan
    pi = 3.141592653589793
    tau = 6.283185307179586

FILE
    /opt/hostedtoolcache/Python/3.8.6/x64/lib/python3.8/lib-dynload/math.cpython-38-x86_64-linux-gnu.so
</pre></div>
</div>
</div>
</div>
<p>Zunächst stellen wir fest, dass die wichtigsten Funktionsklassen wie
trigonometrische und hyperbolische Funktionen sowie ihre Inversen, Logarithmen
und die Exponentialfunktion vorhanden sind. Hinzu kommt noch eine kleine Zahl
speziellere Funktionen wie die Gamma- oder die Fehlerfunktion. Für andere
spezielle Funktionen, beispielsweise Besselfunktionen, steht die numerische Bibliothek
<strong class="program">SciPy</strong> zur Verfügung.</p>
<p>Bei den trigonometrischen Funktionen muss man sich immer die Frage stellen, ob Winkel
im Bogenmaß oder in Grad erwartet werden. Die trigonometrischen Funktionen aus dem
<code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul erwarten Argumente im Bogenmaß.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span>
<span class="n">sin</span><span class="p">(</span><span class="mi">90</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.8939966636005579, 1.0)
</pre></div>
</div>
</div>
</div>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<div class="tip admonition">
<p class="admonition-title">Tipp</p>
<p>Python stellt mit <code class="docutils literal notranslate"><span class="pre">math.tau</span></code> auch die Konstante 2π zur Verfügung, die gelegentlich
als <a class="reference external" href="https://tauday.com/tau-manifesto">fundamentalere Zahl</a> angesehen wird.</p>
</div>
</div>
<p>Wie man sieht, liefert das Argument in Grad nicht das vielleicht erwartete
Ergebnis <code class="docutils literal notranslate"><span class="pre">1</span></code>.  Anders ist dies, wenn man das Argument im Bogenmaß einsetzt. In
diesem Beispiel haben wir übrigens auch ausgenutzt, dass das <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul
einige konstanten definiert, unter anderem eben die Kreiszahl π und die
eulersche Zahl e.</p>
<p>Die Umrechnung zwischen Bogenmaß und Grad kann explizit mit einem Faktor <code class="docutils literal notranslate"><span class="pre">180/π</span></code>
vornehmen oder die Funktionen <code class="xref py py-func docutils literal notranslate"><span class="pre">degrees()</span></code> und <code class="xref py py-func docutils literal notranslate"><span class="pre">radians()</span></code> heranziehen.
Letzteres kann für die Lesbarkeit hilfreich sein. Damit können wir unser obiges
Beispiel für Argumente in Grad anpassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">radians</span>
<span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="mi">90</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0
</pre></div>
</div>
</div>
</div>
<div class="admonition-hinweis admonition">
<p class="admonition-title">Hinweis</p>
<p>Die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">sin()</span></code> hatten wir bereits weiter oben importiert und brauchen
dies daher hier nicht mehr zu tun. In einem größeren Programm würde man
normalerweise alle benötigten <code class="docutils literal notranslate"><span class="pre">import</span></code>-Anweisungen an den Anfang des Programms
stellen.</p>
</div>
<p>Bei der Umrechnung zwischen kartesischen und Polarkoordinaten, deren Beziehung
durch</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
x &amp;= r\cos(\varphi)\\
y &amp;= r\sin(\varphi)
\end{align}\end{split}\]</div>
<p>gegeben ist, kann man den Arkustangens verwenden, um den zu den kartesischen Koordinaten
<span class="math notranslate nohighlight">\((x,y)\)</span> gehörigen Winkel</p>
<div class="math notranslate nohighlight">
\[\varphi = \arctan\left(\frac{y}{x}\right)\]</div>
<p>zu berechnen. Dazu muss man zunächst einmal wissen, dass der Arkustangens in Python
durch die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">atan()</span></code> berechnet wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">atan</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">degrees</span><span class="p">(</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>59.99999999999999
</pre></div>
</div>
</div>
</div>
<p>Wir erhalten also, bis auf einen Rundungsfehler, den erwarteten Winkel von <span class="math notranslate nohighlight">\(60^\circ\)</span>.</p>
<p>Allerdings gibt es zwei Probleme. Zum einen kann der Punkt auf der <span class="math notranslate nohighlight">\(y\)</span>-Achse liegen.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ZeroDivisionError</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">47</span><span class="o">-</span><span class="n">ff65a2210cca</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">3</span> <span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>

<span class="ne">ZeroDivisionError</span>: division by zero
</pre></div>
</div>
</div>
</div>
<p>Hier kommt es überhaupt nicht zur Berechnung des Arkustangens, da schon die Division
fehlschlägt. Das andere Probleme besteht darin, dass man nicht zwischen einem Punkt
und dem am Ursprung gespiegelten Punkt unterscheiden kann.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">degrees</span><span class="p">(</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>59.99999999999999
</pre></div>
</div>
</div>
</div>
<p>Obwohl der Punkt im dritten Quadranten liegt, erhalten wir wieder das Ergebnis <span class="math notranslate nohighlight">\(60^\circ\)</span>,
während das korrekte Ergebnis <span class="math notranslate nohighlight">\(240^\circ\)</span> wäre.</p>
<p>Für solche Fälle stellt Python die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">atan2()</span></code> zur Verfügung.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">atan2</span>
<span class="n">help</span><span class="p">(</span><span class="n">atan2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on built-in function atan2 in module math:

atan2(y, x, /)
    Return the arc tangent (measured in radians) of y/x.
    
    Unlike atan(y/x), the signs of both x and y are considered.
</pre></div>
</div>
</div>
</div>
<p>Wichtig ist hier, dass das erste Argument der Zahl entspricht, die normalerweise im Zähler
des Bruches stehen würde, bei uns also <code class="docutils literal notranslate"><span class="pre">y</span></code>. Unsere Beispiel würde dann folgendermaßen
aussehen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">degrees</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>90.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">degrees</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-120.00000000000001
</pre></div>
</div>
</div>
</div>
<p>Wir erhalten also die erwarteten Ergebnisse, da <span class="math notranslate nohighlight">\(-120^\circ\)</span> äquivalent zu <span class="math notranslate nohighlight">\(240^\circ\)</span> ist.</p>
<p>Im Zusammenhang mit der Umrechnung zwischen kartesischen und Polarkoordinaten hat man
bei der Berechnung des Abstands</p>
<div class="math notranslate nohighlight">
\[r = \sqrt{x^2+y^2}\]</div>
<p>die Wahl, diesen Ausdruck explizit hinzuschreiben oder die in Python vorhandene
<code class="xref py py-func docutils literal notranslate"><span class="pre">hypot()</span></code>-Funktion zu verwenden. Letzteres kann unter anderem dazu dienen, den
Code lesbarer zu machen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2.23606797749979, 2.23606797749979)
</pre></div>
</div>
</div>
</div>
<p>Der Name dieser Funktion erklärt sich daraus, dass hier die Länge der Hypothenuse
berechnet wird. Verwandt hiermit ist die <code class="xref py py-func docutils literal notranslate"><span class="pre">dist()</span></code>-Funktion, die den Abstand
zweier Punkte berechnet. Sowohl <code class="xref py py-func docutils literal notranslate"><span class="pre">dist()</span></code> als auch <code class="xref py py-func docutils literal notranslate"><span class="pre">hypot()</span></code> funktionieren
auch in mehr als zwei Dimensionen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">dist</span>
<span class="n">dist</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.7320508075688772
</pre></div>
</div>
</div>
</div>
<p>In diesem Beispiel ergibt sich wie erwartet die Wurzel aus 3.</p>
<div class="admonition-hinweis admonition">
<p class="admonition-title">Hinweis</p>
<p>Die Verwendung von <code class="xref py py-func docutils literal notranslate"><span class="pre">dist()</span></code> sowie von <code class="xref py py-func docutils literal notranslate"><span class="pre">hypot()</span></code> in mehr als zwei Dimensionen
erfordert mindestens Python 3.8.</p>
</div>
<p>Eine weitere wichtige Klasse von Funktionen, die vom <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul zur Verfügung
gestellt werden, sind die Logarithmen und die Exponentialfunktion. Hier muss man
vor allem zwischen dem natürlichen Logarithmus, der häufig als „ln‟ geschrieben wird,
und dem Zehner- oder dekadischen Logarithmus unterscheiden. In Python wird der natürliche
Logarithmus mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">log()</span></code>-Funktion berechnet und für den dekadischen Logarithmus
gibt es die <code class="xref py py-func docutils literal notranslate"><span class="pre">log10()</span></code>-Funktion. Die gleiche Namensbezeichnungen werden zum Beispiel
in C, Fortran und Julia verwendet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">e</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">log10</span>
<span class="n">log</span><span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">log10</span><span class="p">(</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2.0, -3.0)
</pre></div>
</div>
</div>
</div>
<div class="admonition-hinweis admonition">
<p class="admonition-title">Hinweis</p>
<p>Die <code class="xref py py-func docutils literal notranslate"><span class="pre">log()</span></code>-Funktion akzeptiert noch ein zweites Argument, das dann die Basis
angibt. Damit könnte man den dekadischen Logarithmus auch mit <code class="docutils literal notranslate"><span class="pre">log(x,</span> <span class="pre">10)</span></code> berechnen,
was aber potentiell ungenauer ist als <code class="docutils literal notranslate"><span class="pre">log10(x)</span></code>.</p>
</div>
<p>Neben dem natürlichen Logarithmus <code class="xref py py-func docutils literal notranslate"><span class="pre">log()</span></code> und der Exponentialfunktion <code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code> stellt
Python auch noch die Funktionen <code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code> und <code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code> zur Verfügung. Wozu diese
beiden Funktionen erforderlich sind, wollen wir uns nun ansehen.</p>
<p>Mathematisch stellen Quotienten zweier Funktionen ein Problem dar, wenn sie auf einen Ausdruck
der Form <span class="math notranslate nohighlight">\(0/0\)</span> führen. Man muss dann eine geeignete Grenzwertbildung durchführen oder kann zum
Beispiel den Satz von l’Hôpital anwenden. Numerisch wird das Problem noch dadurch schwieriger,
dass Gleitkommazahlen nach einer gewissen Anzahl von Nachkommastellen abgeschnitten werden.</p>
<p>Wenn wir also beispielsweise den Grenzwert</p>
<div class="math notranslate nohighlight">
\[\lim_{x\to 0} \frac{\mathrm{e}^x-1}{x}\]</div>
<p>numerisch bestimmen wollen, kann es für kleine Werte von <span class="math notranslate nohighlight">\(x\)</span> zu Problemen kommen. Wir könnten
zwar für hinreichend kleine Werte von <span class="math notranslate nohighlight">\(x\)</span> den Zähler mit Hilfe der Taylorreihe für die
Exponentialfunktion</p>
<div class="math notranslate nohighlight">
\[\mathrm{e}^x = \sum_{n=0}^\infty\frac{x^n}{n!}\]</div>
<p>annähern, aber
die <code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code>-Funktion nimmt uns diese Arbeit ab.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">expm1</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.00001</span>
<span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">expm1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1.0000050000069649e-05, 1.0000050000166668e-05)
</pre></div>
</div>
</div>
</div>
<p>Mit Hilfe der führenden Terme der zugehörigen Taylorreihe wird deutlich, dass das Resultat
der <code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code>-Funktion das richtige ist. Die weiteren Terme sind zu klein, um einen
Unterschied zu machen, und da sie positiv sind, würden Sie den Abstand zum Resultat der
<code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code>-Funktion ohnehin nur weiter vergrößern.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.00001</span>
<span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">6</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0000050000166668e-05
</pre></div>
</div>
</div>
</div>
<p>In <a class="reference internal" href="#fig-expm1"><span class="std std-numref">Abb. 3.1</span></a> ist der Unterschied der beiden Berechnungsweisen als Funktion von x
zu sehen. Die durchgezogene Linie ist mit der <code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code>-Funktion berechnet. Sie läuft
in korrekter Weise gegen den Grenzwerten, was man in dieser Auftragung daran sieht, dass
die Abweichung <span class="math notranslate nohighlight">\(f(x)-1\)</span> vom Grenzwert gegen Null geht. Die blauen Punkte sind dagegen mit
der <code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code>-Funktion berechnet. Hier sieht man deutliche Abweichungen unterhalb von
<span class="math notranslate nohighlight">\(x \lesssim 10^{-8}\)</span>, die in der Praxis das gesuchte Ergebnis unter Umständen entscheidend
verfälschen könnten.</p>
<div class="figure align-default" id="fig-expm1">
<a class="reference internal image-reference" href="_images/expm1.png"><img alt="_images/expm1.png" src="_images/expm1.png" style="height: 8cm;" /></a>
<p class="caption"><span class="caption-number">Abb. 3.1 </span><span class="caption-text">Vergleich von <code class="docutils literal notranslate"><span class="pre">exp(x)-1</span></code> (Punkte) und <code class="docutils literal notranslate"><span class="pre">expm1(x)</span></code> (durchgezogene Linie) durch Betrachtung des
Grenzwerts von <span class="math notranslate nohighlight">\(f(x) = (\mathrm{e}^x-1)/x\)</span>.</span><a class="headerlink" href="#fig-expm1" title="Link zu diesem Bild">¶</a></p>
</div>
<p>Der Logarithmus geht für das Argument 1 durch Null, so dass dort Argumente in
der Nähe von 1 einer besonderen Behandlung bedürfen. Hierzu steht in Python für den
natürlichen Logarithmus die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code> zur Verfügung.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log1p</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">),</span> <span class="n">log1p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(9.999950000398841e-06, 9.999950000333332e-06)
</pre></div>
</div>
</div>
</div>
<p>Auch hier kann man sich durch Auswertung der führenden Term der Taylorreihe von</p>
<div class="math notranslate nohighlight">
\[\log(1+x) = \sum_{n=1}^\infty\frac{(-1)^{n+1}x^n}{n}\]</div>
<p>davon überzeugen, dass <code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code> bis auf Rundungsfehler den korrekten Wert liefert.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9.999950000333334e-06
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="komplexe-zahlen">
<h2><span class="section-number">3.4. </span>Komplexe Zahlen<a class="headerlink" href="#komplexe-zahlen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Neben reellen Zahlen benötigt man immer wieder auch komplexe Zahlen. Dabei
erzeugt man einen Imaginärteil durch Anhängen des Buchstabens <code class="docutils literal notranslate"><span class="pre">j</span></code> oder <code class="docutils literal notranslate"><span class="pre">J</span></code>, das
Ingenieure häufig statt des in der Mathematik und Physik üblichen <code class="docutils literal notranslate"><span class="pre">i</span></code> verwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mf">0.5</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.5</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.6+0.8j)
</pre></div>
</div>
</div>
</div>
<p>Alternativ kann man die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code> verwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z1</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">z2</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">z1</span><span class="o">/</span><span class="n">z2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.6+0.8j)
</pre></div>
</div>
</div>
</div>
<p>Möchte man aus den Werten zweier Variablen eine komplexe Zahl
konstruieren, geht dies mit der zweiten der gerade genannten Methoden
sehr einfach</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">z1</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">z2</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span>
<span class="n">z1</span><span class="o">/</span><span class="n">z2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(-0.6+0.8j)
</pre></div>
</div>
</div>
</div>
<p>Falls man die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code> nicht verwenden möchte, muss man
beachten, dass die folgenden beiden Wege nicht zum Ziel führen.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">18</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">yj</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">62</span><span class="o">-</span><span class="mi">1710</span><span class="n">c726c088</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">18</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">9</span>
<span class="ne">----&gt; </span><span class="mi">3</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">yj</span>

<span class="ne">NameError</span>: name &#39;yj&#39; is not defined
</pre></div>
</div>
</div>
</div>
<p>Hier geht Python davon aus, dass es sich bei <code class="docutils literal notranslate"><span class="pre">yj</span></code> um eine Variable handelt,
der aber noch kein Wert zugewiesen wurde, die also noch nicht definiert ist,
wie Python in der Fehlermeldung sagt. Dies lässt sich leicht überprüfen, wenn
man neben <code class="docutils literal notranslate"><span class="pre">x</span></code>, dem wir schon den Wert 18 zugewiesen haben, noch einen Wert
für <code class="docutils literal notranslate"><span class="pre">yj</span></code> setzt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">yj</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">x</span><span class="o">+</span><span class="n">yj</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>42
</pre></div>
</div>
</div>
</div>
<p>Genauso verhält es sich, wenn wir versuchen, die Variable <code class="docutils literal notranslate"><span class="pre">y</span></code>, die den Imaginärteil
repräsentieren soll, mit <code class="docutils literal notranslate"><span class="pre">j</span></code> zu multiplizieren. <code class="docutils literal notranslate"><span class="pre">j</span></code> würde von Python wieder als noch
undefinierte Variable angesehen und so erklärt sich dann auch die Fehlermeldung.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">j</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">64</span><span class="o">-</span><span class="n">a842156597de</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">j</span>

<span class="ne">NameError</span>: name &#39;j&#39; is not defined
</pre></div>
</div>
</div>
</div>
<p>Vielmehr muss die imaginäre Einheit explizit als <code class="docutils literal notranslate"><span class="pre">1j</span></code> geschrieben
werden. Den Grund hierfür werden wir noch genauer verstehen, wenn wir in
<a class="reference internal" href="#variablen"><span class="std std-numref">Kapitel 3.5</span></a> besprechen, welche Namen für Variablen zugelassen
sind.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
<span class="n">z</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(18+9j)
</pre></div>
</div>
</div>
</div>
<p>Das Resultat für <code class="docutils literal notranslate"><span class="pre">z</span></code> ergibt sich aus den weiter oben definierten Werten von <code class="docutils literal notranslate"><span class="pre">x</span></code> und <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<div class="admonition-aufgabe admonition">
<p class="admonition-title">Aufgabe</p>
<p>Zeigen Sie an einem oder mehreren Beispielen, dass das Ergebnis einer Rechnung,
die komplexe Zahlen enthält, selbst dann als komplexe Zahl dargestellt wird, wenn
das Ergebnis reell ist.</p>
</div>
<p>Hat man eine komplexe Zahl einer Variablen zugewiesen, wie wir dies in <a class="reference internal" href="#variablen"><span class="std std-numref">Kapitel 3.5</span></a>
noch genauer diskutieren werden, so lassen sich aus der Variablen wieder der Real- und
der Imaginärteil extrahieren.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mf">0.5</span><span class="n">j</span>
<span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1.0, 0.5)
</pre></div>
</div>
</div>
</div>
<p>Man kann sich auch die konjugiert komplexe Zahl beschaffen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1-0.5j)
</pre></div>
</div>
</div>
</div>
<p>Die Unterschiede in den Aufrufen ergeben sich daraus, dass bei Real- und
Imaginärteil auf Attribute, also Eigenschaften, der komplexen Zahl zugegriffen
wird, während bei der komplexen Konjugation eine Methode aufgerufen wird, die
etwas mit der komplexen Zahl macht. Es mag an dieser Stelle verwirren, dass man
nicht alternativ <code class="docutils literal notranslate"><span class="pre">conjugate(x)</span></code> verwenden kann. Die Hintergründe werden im
<a class="reference internal" href="objektorientiert.html#oop"><span class="std std-numref">Kapitel 9</span></a> klarer werden, wo wir uns mit dem objektorientierten
Programmieren beschäftigen werden.</p>
<p>Natürlich wollen wir auch für komplexe Zahlen mathematische Funktionen
auswerten. Das Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code> hilft hier aber leider nicht weiter,
da es nur mit reellen Zahlen umgehen kann und erfolglos versucht, das
komplexe Argument in eine reelle Zahl umzuwandeln. Python wäre durchaus in
der Lage, eine reelle Zahl in eine komplexe Zahl umzuwandeln, aber für den
umgekehrten Weg gibt es keine mathematisch eindeutige Vorschrift, die
Python verwenden könnte.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span>
<span class="n">exp</span><span class="p">(</span><span class="mf">0.25</span><span class="n">j</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">68</span><span class="o">-</span><span class="mi">1</span><span class="n">af733aa4184</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">exp</span><span class="p">(</span><span class="mf">0.25</span><span class="n">j</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>

<span class="ne">TypeError</span>: can&#39;t convert complex to float
</pre></div>
</div>
</div>
</div>
<p>Es gibt jedoch in der Python-Standardbibliothek ein Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code>, das mit komplexen
Zahlen umgehen kann.</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cmath</span>
<span class="n">help</span><span class="p">(</span><span class="n">cmath</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on module cmath:

NAME
    cmath

MODULE REFERENCE
    https://docs.python.org/3.8/library/cmath
    
    The following documentation is automatically generated from the Python
    source files.  It may be incomplete, incorrect or include features that
    are considered implementation detail and may vary between Python
    implementations.  When in doubt, consult the module reference at the
    location listed above.

DESCRIPTION
    This module provides access to mathematical functions for complex
    numbers.

FUNCTIONS
    acos(z, /)
        Return the arc cosine of z.
    
    acosh(z, /)
        Return the inverse hyperbolic cosine of z.
    
    asin(z, /)
        Return the arc sine of z.
    
    asinh(z, /)
        Return the inverse hyperbolic sine of z.
    
    atan(z, /)
        Return the arc tangent of z.
    
    atanh(z, /)
        Return the inverse hyperbolic tangent of z.
    
    cos(z, /)
        Return the cosine of z.
    
    cosh(z, /)
        Return the hyperbolic cosine of z.
    
    exp(z, /)
        Return the exponential value e**z.
    
    isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)
        Determine whether two complex numbers are close in value.
        
          rel_tol
            maximum difference for being considered &quot;close&quot;, relative to the
            magnitude of the input values
          abs_tol
            maximum difference for being considered &quot;close&quot;, regardless of the
            magnitude of the input values
        
        Return True if a is close in value to b, and False otherwise.
        
        For the values to be considered close, the difference between them must be
        smaller than at least one of the tolerances.
        
        -inf, inf and NaN behave similarly to the IEEE 754 Standard. That is, NaN is
        not close to anything, even itself. inf and -inf are only close to themselves.
    
    isfinite(z, /)
        Return True if both the real and imaginary parts of z are finite, else False.
    
    isinf(z, /)
        Checks if the real or imaginary part of z is infinite.
    
    isnan(z, /)
        Checks if the real or imaginary part of z not a number (NaN).
    
    log(...)
        log(z[, base]) -&gt; the logarithm of z to the given base.
        
        If the base not specified, returns the natural logarithm (base e) of z.
    
    log10(z, /)
        Return the base-10 logarithm of z.
    
    phase(z, /)
        Return argument, also known as the phase angle, of a complex.
    
    polar(z, /)
        Convert a complex from rectangular coordinates to polar coordinates.
        
        r is the distance from 0 and phi the phase angle.
    
    rect(r, phi, /)
        Convert from polar coordinates to rectangular coordinates.
    
    sin(z, /)
        Return the sine of z.
    
    sinh(z, /)
        Return the hyperbolic sine of z.
    
    sqrt(z, /)
        Return the square root of z.
    
    tan(z, /)
        Return the tangent of z.
    
    tanh(z, /)
        Return the hyperbolic tangent of z.

DATA
    e = 2.718281828459045
    inf = inf
    infj = infj
    nan = nan
    nanj = nanj
    pi = 3.141592653589793
    tau = 6.283185307179586

FILE
    /opt/hostedtoolcache/Python/3.8.6/x64/lib/python3.8/lib-dynload/cmath.cpython-38-x86_64-linux-gnu.so
</pre></div>
</div>
</div>
</div>
<p>Damit können wir nun die Exponentialfunktion auf eine komplexe Zahl anwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cmath</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span>
<span class="n">exp</span><span class="p">(</span><span class="mf">0.25</span><span class="n">j</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.7071067811865476+0.7071067811865475j)
</pre></div>
</div>
</div>
</div>
<p>Dabei ist das Ergebnis immer eine komplexe Zahl. Daher kann es wünschenswert
sein, sowohl das Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code> als auch das Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> zu
importieren:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">cmath</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reelle Exponentialfunktion:   </span><span class="si">{</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;komplexe Exponentialfunktion: </span><span class="si">{</span><span class="n">cmath</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.25</span><span class="n">j</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>reelle Exponentialfunktion:   7.38905609893065
komplexe Exponentialfunktion: (0.7071067811865476+0.7071067811865475j)
</pre></div>
</div>
</div>
</div>
<p>Bei dieser Art des Imports ist durch die Notwendigkeit, das Modul anzugeben,
immer klar, um welche Funktion es sich handelt.</p>
<p>Eine andere Möglichkeit wäre ein Umbenennung von einer der beiden Funktionen,
wobei der Name nicht zwingend <code class="docutils literal notranslate"><span class="pre">cexp</span></code> sein müsste..</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">cmath</span> <span class="kn">import</span> <span class="n">exp</span> <span class="k">as</span> <span class="n">cexp</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reelle Exponentialfunktion:   </span><span class="si">{</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;komplexe Exponentialfunktion: </span><span class="si">{</span><span class="n">cexp</span><span class="p">(</span><span class="mf">0.25</span><span class="n">j</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>reelle Exponentialfunktion:   7.38905609893065
komplexe Exponentialfunktion: (0.7071067811865476+0.7071067811865475j)
</pre></div>
</div>
</div>
</div>
<div class="admonition-frage admonition">
<p class="admonition-title">Frage</p>
<p>Welche Funktion wird verwendet, wenn man nacheinander die Funktion
<code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code> aus dem Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code> und aus dem Modul <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> importiert
ohne wie im vorigen Beispiel eine Umbenennung durchzuführen? Probieren Sie es
einfach mal aus.</p>
</div>
</div>
<div class="section" id="variablen-und-zuweisungen">
<span id="variablen"></span><h2><span class="section-number">3.5. </span>Variablen und Zuweisungen<a class="headerlink" href="#variablen-und-zuweisungen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Aus der Mathematik kennen wir das Konzept von Variablen, denen man je nach
Anwendungsfall bestimmte Werte zuweisen kann. Es ist aber auch möglich, auf die
explizite Zuweisung von Werten gänzlich zu verzichten und mit Variablen rein
symbolisch zu rechnen. Wir werden im Folgenden immer den ersten Fall im Blick
haben, bei dem Variablen ein Wert zugewiesen wird, der sich im Lauf der
Programmabarbeitung auch verändern kann. Variablen sind in diesem Sinne Namen
für Bereiche im Computerspeicher, die bestimmte Informationen enthalten.</p>
<p>Die Beschränkung auf den ersten Fall bedeutet jedoch nicht, dass es auf Computern
nicht möglich wäre, auch rein symbolisch zu rechnen, wie Computeralgebrasysteme
zeigen. Auch in Python ist mit Hilfe der <a class="reference external" href="https://www.sympy.org/"><code class="docutils literal notranslate"><span class="pre">sympy</span></code>-Bibliothek</a>
symbolisches Rechnen möglich.</p>
<p>Eine Variable soll nun den Speicherplatz bezeichnen, in dem ein bestimmtes Objekt,
also zum Beispiel eine Zahl, eine Zeichenkette oder ein Objekt eines der anderen
Datentypen, die wir noch kennenlernen werden, abgespeichert ist. Bedenkt man, dass
der Ort im Speicher auch einfach durch eine Zahl angegeben werden könnte, wird klar,
dass Variablen eine wichtige Rolle dabei spielen, ein Programm gut lesbar zu machen.</p>
<div class="tip admonition">
<p class="admonition-title">Tipp</p>
<p>Es lohnt sich, bewusst beschreibende Variablennamen zu wählen, auch wenn es etwas Mühe kostet.
In den meisten Fällen sind hierfür Variablennamen, die nur aus einem Buchstaben bestehen,
ungeeignet, auch wenn sie bequem erscheinen mögen. Denken Sie daran, dass es für andere
nicht offensichtlich sein wird, was die Bedeutung einer Variablen <code class="docutils literal notranslate"><span class="pre">x</span></code> im konkreten Fall
ist. Unter Umständen handelt es sich bei dieser anderen Person auch um Sie selbst, wenn
Sie nach einem halben Jahr wieder einen Blick auf Ihr Programm werfen. Eine beschreibende
Benennung von Variablen ist ein wesentlicher Schritt zu einem gut dokumentierten Programm.</p>
</div>
<p>Wie muss ein Variablenname oder allgemein ein Bezeichner aufgebaut sein, damit er als
solcher erkannt wird? Die Antwort hängt von der benutzten Programmiersprache ab, so dass
wir sie hier konkret für Python beantworten werden. Die wesentlichen Aspekte gelten aber
auch für die anderen verbreiteten Programmiersprachen für wissenschaftliche Anwendungen.</p>
<p>In Python besteht ein Bezeichner aus einer beliebigen Zahl von Zeichen, wobei
Buchstaben, der Unterstrich (<code class="docutils literal notranslate"><span class="pre">_</span></code>) und Ziffern zugelassen sind. Das erste Zeichen
darf jedoch keine Ziffer sein. Der Unterstrich zu Beginn und am Ende eines Bezeichners
impliziert üblicherweise eine spezielle Bedeutung, auf die wir später noch zurückkommen
werden. Daher sollte man es sich zur Regel machen, den Unterstrich höchstens innerhalb
eines Bezeichners zu verwenden, sofern man nicht bewusst den Unterstrich in anderer
Weise einsetzt.</p>
<p>Viel interessanter als Unterstriche sind Buchstaben. Diese umfassen zunächst
einmal die Großbuchstaben <code class="docutils literal notranslate"><span class="pre">A-Z</span></code> und Kleinbuchstaben <code class="docutils literal notranslate"><span class="pre">a-z</span></code>. Wie sieht es
aber mit Umlauten oder gar mit Buchstaben aus anderen Schriftsystemen,
beispielsweise griechischen Buchstaben aus? In diesem Zusammenhang stellt sich
die Frage, wie Zeichen im Rechner überhaupt in einer binären Form dargestellt
werden. Es gibt hierfür zahlreiche Standards, unter anderem den ASCII-Standard,
der noch nicht einmal Umlaute kennt, den ISO-8859-1-Standard, der diesen
Mangel behebt, aber dennoch im Umfang sehr beschränkt ist, bis hin zum
Unicode-Standard, der mehr als hunderttausend Zeichen umfasst. Für den
Unicode-Standard gibt es wiederum verschiedene Codierungen, insbesondere die in
der westlichen Welt sinnvolle UTF-8-Kodierung. Etwas mehr Details zu diesem
Thema sind im <a class="reference internal" href="unicode.html#appendixunicode"><span class="std std-numref">Kapitel 13</span></a> zu finden.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Ein technisch präzise Beschreibung der erlaubten Zeichen findet sich in der
<a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">Sprachdokumentation von Python</a>.</p>
</div>
</div>
<p>Die systematische Unterstützung des Unicode-Standards durch Python impliziert,
dass Buchstaben in Bezeichnern alle Zeichen sein können, die im
Unicode-Standard als Buchstaben angesehen werden, also neben Umlauten zum
Beispiel auch griechische Zeichen. Ob es wirklich sinnvoll ist, Buchstaben von
außerhalb des Bereiche <code class="docutils literal notranslate"><span class="pre">A-Z</span></code> und <code class="docutils literal notranslate"><span class="pre">a-z</span></code> zu verwenden, sollte man sich im
Einzelfall gut überlegen. Man muss sich nur vor Augen halten, was es für Folgen
hätte, wenn man ein Programm analysieren müsste, das unter Verwendung von
chinesischen Schriftzeichen geschrieben wurde. Dennoch ist zum Beispiel der
folgende Code für Python 3 kein Problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span> <span class="k">as</span> <span class="n">π</span>
<span class="n">Radius</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Fläche</span> <span class="o">=</span> <span class="n">π</span><span class="o">*</span><span class="n">Radius</span><span class="o">**</span><span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Fläche</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>12.566370614359172
</pre></div>
</div>
</div>
</div>
<p>Es ist nicht selbstverständlich, dass Variablennamen mit Umlauten, griechischen
Buchstaben oder allgemein Zeichen außerhalb der Bereiche <code class="docutils literal notranslate"><span class="pre">A-Z</span></code> und <code class="docutils literal notranslate"><span class="pre">a-z</span></code>
in anderen Programmiersprachen ebenfalls zugelassen sind. Will man solche Zeichen
überhaupt verwenden, so sollte man sich hierüber informieren.</p>
<p>Bei einer Programmiersprache ist auch immer die Frage zu klären, ob zwischen
Groß- und Kleinschreibung unterschieden wird. Python tut dies, so dass <code class="docutils literal notranslate"><span class="pre">var</span></code>,
<code class="docutils literal notranslate"><span class="pre">Var</span></code> und <code class="docutils literal notranslate"><span class="pre">VAR</span></code> verschiedene Variablen bezeichnen und für Python nichts
miteinander zu tun haben. Auch hier stellt sich im Einzelfall die Frage, ob es
sinnvoll ist, in einem Programm einen Variablennamen gleichzeitig in Groß- und
Kleinschreibung zu verwenden. Es ist jedoch wichtig zu wissen, dass eine
Fehlfunktion des Programms ihren Ursprung in einem Tippfehler haben kann, bei
dem Groß- und Kleinschreibung nicht beachtet wurden.</p>
<p>Für die Verständlichkeit des Programmcodes ist es angebracht, möglichst
aussagekräftige Bezeichner zu verwenden, auch wenn diese im Allgemeinen etwas
länger ausfallen. Dabei kann es sinnvoll sein, einen Bezeichner aus mehreren
Wörtern zusammenzusetzen. Um die einzelnen Bestandteile erkennen zu können,
sind verschiedene Varianten üblich. Man kann zur Trennung einen Unterstrich
verwenden, z.B. <code class="docutils literal notranslate"><span class="pre">sortiere_liste</span></code>. Alternativ kann man neue Worte mit einem
Großbuchstaben beginnen, wobei der erste Buchstabe des Bezeichners groß oder
klein geschrieben werden kann, z.B. <code class="docutils literal notranslate"><span class="pre">sortiereListe</span></code> oder <code class="docutils literal notranslate"><span class="pre">SortiereListe</span></code>.
Im ersten Fall spricht man von <em>mixedCase</em>, im zweiten Fall von <em>CamelCase</em>, da
die Großbuchstaben an Höcker eines Kamels erinnern. Details zu den in Python
empfohlenen Konventionen für Bezeichner finden Sie im Python Enhancement Proposal <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a>
mit dem Titel »Style Guide for Python Code« im Abschnitt <em>Naming Conventions</em>.</p>
<p>In Python existieren eine Reihe von Schlüsselwörtern, die als Sprachelemente reserviert
sind und daher nicht für Bezeichner verwendet werden dürfen. Die aktuelle Liste lässt
sich mit einem kleinen Python-Programm erzeugen oder einfach in der <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">Sprachdokumentation von
Python</a> nachschlagen.
Wichtiger als das kurze Programm, das wir an dieser Stelle noch nicht vollständig verstehen
können, ist das Ergebnis der reservierten Schlüsselwörter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keyword</span> <span class="kn">import</span> <span class="n">kwlist</span>

<span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">kw</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kwlist</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">kw</span><span class="si">:</span><span class="s1">&lt;10s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nr</span> <span class="o">%</span> <span class="mi">7</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False     None      True      and       as        assert    async     
await     break     class     continue  def       del       elif      
else      except    finally   for       from      global    if        
import    in        is        lambda    nonlocal  not       or        
pass      raise     return    try       while     with      yield     
</pre></div>
</div>
</div>
</div>
<div class="warning admonition">
<p class="admonition-title">Wichtiger Hinweis</p>
<p>Da griechische Buchstaben in der Physik relativ häufig sind, ist
insbesondere darauf zu achten, dass <code class="docutils literal notranslate"><span class="pre">lambda</span></code> reserviert ist. Der Grund hierfür
liegt darin, dass Python so genannte Lambdafunktionen zur Verfügung stellt, die
wir im <a class="reference internal" href="funktionen.html#lambdafunktionen"><span class="std std-numref">Kapitel 5.6</span></a> diskutieren werden.</p>
</div>
<p>Variablen kann nun ein Wert zugewiesen werden. Die Zuweisung wird dabei durch
ein Gleichheitszeichen gekennzeichnet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nach der ersten Zuweisung:  x = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nach der zweiten Zuweisung: x = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>nach der ersten Zuweisung:  x = 1
nach der zweiten Zuweisung: x = 2
</pre></div>
</div>
</div>
</div>
<p>In der ersten Zeile wird der Variable <code class="docutils literal notranslate"><span class="pre">x</span></code> der Wert 1 zugewiesen. Die dritte
Zeile zeigt deutlich, dass das Gleichheitszeichen nicht im Sinne einer
mathematischen Gleichung interpretiert werden darf. Mathematisch hätte diese
Gleichung nämlich keine Lösung. In einer Zuweisung wird vielmehr der Code auf
der rechten Seite des Gleichheitszeichens ausgewertet. Zu diesem Zeitpunkt hat
<code class="docutils literal notranslate"><span class="pre">x</span></code> noch den Wert 1, so dass sich nach der Addition der Wert 2 ergibt. Dieser
Wert wird anschließend der Variablen <code class="docutils literal notranslate"><span class="pre">x</span></code> zugewiesen, die nun den Wert 2 besitzt.
Die Zuweisung ist also eher als <code class="docutils literal notranslate"><span class="pre">x+1</span></code> → <code class="docutils literal notranslate"><span class="pre">x</span></code> zu verstehen.</p>
<p>Sich die zeitliche Abfolge von Zuweisungen klar zu machen, ist zum Beispiel wichtig,
wenn man zwei Werte vertauschen möchte. Im folgenden Beispiel weisen wir der Variable
<code class="docutils literal notranslate"><span class="pre">x</span></code> den Wert 1 zu und der Variable <code class="docutils literal notranslate"><span class="pre">y</span></code> den Wert 2. Wir möchten die beiden Werte nun
vertauschen, so dass <code class="docutils literal notranslate"><span class="pre">x</span></code> den Wert 2 bekommt und <code class="docutils literal notranslate"><span class="pre">y</span></code> den Wert 1. Das soll unabhängig
davon funktionieren, welchen konkreten Wert die beiden Variablen zunächst haben. Man
könnte zunächst versucht sein, das Problem auf die folgende Weise zu lösen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2 2
</pre></div>
</div>
</div>
</div>
<p>Offenbar haben wir auf diese Weise den ursprünglichen Wert von <code class="docutils literal notranslate"><span class="pre">x</span></code> verloren. Das Problem
ist die dritte Zeile, in der wir der Variable <code class="docutils literal notranslate"><span class="pre">x</span></code> den Wert von <code class="docutils literal notranslate"><span class="pre">y</span></code>, also 2, zuweisen.
Damit wurde der vorherige Wert 1 überschrieben und dieser kann auch in der vierten Zeile
nicht auf magische Weise wieder auftreten.</p>
<p>Die Standardlösung für dieses Problem besteht darin, den Wert von <code class="docutils literal notranslate"><span class="pre">x</span></code> in einer Variablen
zwischenzuspeichern.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2 1
</pre></div>
</div>
</div>
</div>
<p>Hier wird in der dritten Zeile der Wert von <code class="docutils literal notranslate"><span class="pre">x</span></code> der Variablen <code class="docutils literal notranslate"><span class="pre">tmp</span></code> zugewiesen, die wir
so genannt haben, weil sie nur temporär zur Zwischenspeicherung benötigt wird. Ihren Wert
können wir dann in der fünften Zeile verwenden, um <code class="docutils literal notranslate"><span class="pre">y</span></code> den ursprünglichen Wert von <code class="docutils literal notranslate"><span class="pre">x</span></code>
zuzuweisen, der in <code class="docutils literal notranslate"><span class="pre">x</span></code> ja bereits überschrieben wurde.</p>
<p>In Python lässt sich das Problem noch eleganter in folgender Weise lösen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2 1
</pre></div>
</div>
</div>
</div>
<p>Dies Lösung vermeidet die Einführung einer weiteren Variablen und erfordert auch keine
drei Zeile Code, deren Funktion man erst analysieren muss. Vielmehr stellt die dritte
Zeile sehr kompakt dar, was passiert. Genau genommen wird hier ein aus zwei Variablen
bestehendes Tupel einem anderen Tupel zugewiesen. Dies geschieht parallel, so dass es
zu keiner unerwünschten Überschreibung wie zuvor kommen kann. Ein Tupel ist ein
zusammengesetzter Datentyp, den wir in <a class="reference internal" href="sequenzen.html#tupel"><span class="std std-numref">Kapitel 6.2</span></a> genauer diskutieren werden.
Seine Verwendung trägt in unserem Beispiel erheblich dazu bei, den Code gut lesbar
zu machen.</p>
<p>In den Zuweisungen haben wir vor und nach dem Gleichheitszeichen jeweils ein
Leerzeichen gesetzt. Dies ist nicht zwingend notwendig, verbessert aber die
Lesbarkeit des Codes und wird daher auch im bereits weiter oben erwähnten Python
Enhancement Proposal <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> empfohlen. Es ist durchaus sinnvoll, sich zumindest
an die wesentlichen der in PEP 8 enthaltenen Empfehlungen zu halten, um anderen
Personen das Lesen des Codes zu erleichtern.</p>
<p>Eine weitere Empfehlung lautet, eine Zeilenlänge von 79 Zeichen nicht zu
überschreiten, auch wenn diese Vorgabe in Zeiten großer Bildschirme nicht mehr
ganz so streng gesehen wird Bei überlangen Zeilen kann man mit einem Backslash
(<code class="docutils literal notranslate"><span class="pre">\</span></code>) am Zeilenende eine Fortsetzungszeile erzeugen. In gewissen Fällen erkennt der
Python-Interpreter, dass eine Fortsetzungszeile folgen muss, so dass dann der
Backslash entfallen kann. Dies ist insbesondere der Fall, wenn in einer Zeile
eine Klammer geöffnet wird, die dann erst in einer Folgezeile wieder
geschlossen wird.</p>
<p>Es wird häufig empfohlen, den Backslash zur Kennzeichnung einer
Fortsetzungszeile zu vermeiden. Stattdessen sollte eine Klammerung verwendet
werden, selbst wenn diese ausschließlich zur impliziten Markierung von
Fortsetzungszeilen dient. Im folgenden Beispiel wird deutlich, wie man die
Klammerung einsetzen kann, auch wenn man die Addition kaum über zwei Zeilen
verteilen wird. Im ersten Fall erwartet Python nach dem Pluszeichen den zweiten
Summanden, der auf dieser Zeile aber nicht zu finden ist.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span><span class="o">+</span>
<span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-79-93104a7e2633&gt;&quot;</span><span class="gt">, line </span><span class="mi">1</span>
<span class="g g-Whitespace">    </span><span class="mi">4</span><span class="o">+</span>
      <span class="o">^</span>
<span class="ne">SyntaxError</span>: invalid syntax
</pre></div>
</div>
</div>
</div>
<p>Anders ist dies nach einer öffnenden Klammer, da Python dann den Code bis zur
zugehörigen schließenden Klammer liest.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">4</span><span class="o">+</span>
<span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="wahrheitswerte">
<h2><span class="section-number">3.6. </span>Wahrheitswerte<a class="headerlink" href="#wahrheitswerte" title="Link zu dieser Überschrift">¶</a></h2>
<p>Im <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> hatten wir schon gesehen, dass man den Ablauf eines
Programms in Abhängigkeit davon beeinflussen kann, ob eine bestimmte Bedingung
erfüllt ist oder nicht. In diesem Zusammenhang spielen Wahrheitswerte oder so
genannte boolesche Variable eine Rolle.</p>
<p>Mit einem Wahrheitswert kann die Gültigkeit einer Aussage mit »wahr« oder
»falsch« spezifiziert werden.  Mögliche Werte in Python sind entsprechend
<code class="docutils literal notranslate"><span class="pre">True</span></code> und <code class="docutils literal notranslate"><span class="pre">False</span></code>, wobei die Großschreibung des ersten Zeichens wichtig
ist. Für die bis jetzt behandelten Datentypen (Integer, Float, Complex) gilt,
dass eine Null dem Wert <code class="docutils literal notranslate"><span class="pre">False</span></code> entspricht, während alle anderen Zahlenwerte
einem <code class="docutils literal notranslate"><span class="pre">True</span></code> entsprechen. Dies lässt sich durch eine explizite Umwandlung mit
Hilfe der Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code> überprüfen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Wichtige logische Operatoren sind <code class="docutils literal notranslate"><span class="pre">not</span></code> (Negation), <code class="docutils literal notranslate"><span class="pre">and</span></code> (logisches Und)
und <code class="docutils literal notranslate"><span class="pre">or</span></code> (logisches Oder). Bei der Negation wird aus <code class="docutils literal notranslate"><span class="pre">True</span></code> <code class="docutils literal notranslate"><span class="pre">False</span></code> und umgekehrt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
<span class="ow">not</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>Nehmen wir noch einen zweiten Wahrheitswert hinzu, so können wir die <code class="docutils literal notranslate"><span class="pre">and</span></code>-Operation
durchführen, die nur dann <code class="docutils literal notranslate"><span class="pre">True</span></code> ergibt, wenn beide beteiligten Ausdrücke den
Wahrheitswert <code class="docutils literal notranslate"><span class="pre">True</span></code> haben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">x</span> <span class="ow">and</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>Die <code class="docutils literal notranslate"><span class="pre">or</span></code>-Operation ergibt <code class="docutils literal notranslate"><span class="pre">True</span></code> wenn mindestens einer der beiden beteiligten Ausdrücke
den Wahrheitswert <code class="docutils literal notranslate"><span class="pre">True</span></code> hat. Diese Operation muss vom exklusiven Oder unterschieden werden,
das nur <code class="docutils literal notranslate"><span class="pre">True</span></code> ergibt, wenn genau einer der beiden Wahrheitswerte gleich <code class="docutils literal notranslate"><span class="pre">True</span></code> ist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="ow">or</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Logische Ausdrücke werden in Python von links nach rechts ausgewertet und zwar
nur so weit, wie es für die Entscheidung über den Wahrheitswert erforderlich ist.
Dies wird in dem folgenden Beispiel illustriert. Im ersten Fall steht das Ergebnis der
<code class="docutils literal notranslate"><span class="pre">or</span></code>-Verknüpfung schon dadurch fest, dass <code class="docutils literal notranslate"><span class="pre">x</span></code> gleich <code class="docutils literal notranslate"><span class="pre">True</span></code> ist, so dass die Division
durch Null nicht mehr durchgeführt wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x</span> <span class="ow">or</span> <span class="mi">1</span><span class="o">/</span><span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Anders ist dies bei der <code class="docutils literal notranslate"><span class="pre">and</span></code>-Verknüpfung. Hier wird die Division ausgeführt mit den
bekannten Folgen einer Division durch Null.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="ow">and</span> <span class="mi">1</span><span class="o">/</span><span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ZeroDivisionError</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">87</span><span class="o">-</span><span class="mi">1</span><span class="n">caaeadbca49</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">x</span> <span class="ow">and</span> <span class="mi">1</span><span class="o">/</span><span class="n">y</span>

<span class="ne">ZeroDivisionError</span>: division by zero
</pre></div>
</div>
</div>
</div>
<p>Wahrheitswerte sind häufig das Ergebnis von Vergleichsoperationen, die in der
<a class="reference internal" href="#table-comparison"><span class="std std-numref">Tab. 3.2</span></a> zusammengestellt sind.</p>
<table class="table" id="table-comparison">
<caption><span class="caption-number">Tab. 3.2 </span><span class="caption-text">Vergleichsoperationen in Python</span><a class="headerlink" href="#table-comparison" title="Link zu dieser Tabelle">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator</p></th>
<th class="head"><p>Bedeutung</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p>kleiner</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
<td><p>kleiner oder gleich</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p>größer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td><p>größer oder gleich</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td><p>ungleich</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>gleich</p></td>
</tr>
</tbody>
</table>
<p>Die folgenden drei Beispiele illustrieren Vergleichsoperationen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">!=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="warning admonition">
<p class="admonition-title">Wichtiger Hinweis</p>
<p>Ein beliebter Fehler besteht darin, beim Test auf Gleichheit nur eines
statt zwei Gleichheitszeichen zu verwenden.</p>
</div>
<p>Hat man es mit Gleitkommazahlen zu tun, so ist ein Test auf Gleichheit meistens
nicht sinnvoll, das Rundungsfehler dazu führen können, dass das Ergebnis nicht
wie erwartet ausfällt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="mf">0.1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>In solchen Fällen ist es besser zu überprüfen, ob die Differenz von zwei
Gleitkommazahlen eine vertretbare Schwelle unterschreitet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-12</span>
<span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>In diesem Zusammenhang kann auch die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">isclose()</span></code> aus dem <code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code>-Modul
hilfreich sein, das sowohl absolute als auch relative Abweichungen berücksichtigen kann.</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">help</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Help on built-in function isclose in module math:

isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)
    Determine whether two floating point numbers are close in value.
    
      rel_tol
        maximum difference for being considered &quot;close&quot;, relative to the
        magnitude of the input values
      abs_tol
        maximum difference for being considered &quot;close&quot;, regardless of the
        magnitude of the input values
    
    Return True if a is close in value to b, and False otherwise.
    
    For the values to be considered close, the difference between them
    must be smaller than at least one of the tolerances.
    
    -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
    is, NaN is not close to anything, even itself.  inf and -inf are
    only close to themselves.
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="formatierung-von-ausgaben">
<span id="formatierung"></span><h2><span class="section-number">3.7. </span>Formatierung von Ausgaben<a class="headerlink" href="#formatierung-von-ausgaben" title="Link zu dieser Überschrift">¶</a></h2>
<p>Wenn man ein Programm ausführt, möchte man in den meisten Fällen eine Ausgabe
haben, die im einfachsten Fall auf dem Bildschirm erfolgen kann. In den
Codezellen eines Jupyter Notebooks, wie wir sie in diesem Manuskript verwenden,
kann man am Ende der Zelle einfach eine Variable oder einen Ausdruck
hinschreiben. Dieser wird ausgewertet und das Ergebnis ausgegeben. Dabei
handelt es sich zwar um eine bequeme Art der Ausgabe, die aber in Python im
Allgemeinen und auch in anderen Programmiersprachen so nicht funktionieren
wird.</p>
<p>Stattdessen muss man die <code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion verwenden, die in anderen
Programmiersprachen auch einen anderen Namen, beispielsweise <code class="docutils literal notranslate"><span class="pre">write</span></code>, haben kann.
Die <code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion ist uns auch schon in einigen Beispielen begegnet.</p>
<p>Die Ein- und Ausgabe von Daten werden wir erst später im <a class="reference internal" href="einausgabe.html#einausgabe"><span class="std std-numref">Kapitel 7</span></a>
genauer diskutieren. Dennoch wollen wir uns schon jetzt mit der Frage beschäftigen,
wie man eine Ausgabe in das gewünschte Format bringen kann. Gerade beim Arbeiten mit
numerischen Datentypen, die wir zu Beginn dieses Kapitels eingeführt hatten, möchte
man unter Umständen in der Lage sein, die Zahl der Nachkommastellen festzulegen oder
eine Exponentialschreibweise zu wählen.</p>
<p>Die Möglichkeit, das Format der Ausgabe festzulegen, ist zumindest in allen für
das wissenschaftliche Arbeiten relevanten Programmiersprache gegeben. Die
Beschreibung des Formats funktioniert typischerweise mit Hilfe eines <em>format
strings</em>, der in den verschiedenen Programmiersprachen ähnlich aufgebaut ist,
auch wenn es im Detail durchaus Unterschiede geben kann. Wie die auszugebenden
Objekte und ihre Formatierung dann im Code anzugeben sind, unterscheidet sich
von Programmiersprache zu Programmiersprache. Python selbst stellt hierfür schon
mehrere Möglichkeiten zur Verfügung. Mit der Version 3.6 wurden die so genannten
f-Strings eingeführt, wobei der englische Begriff <em>string</em> hier im Sinne einer
Zeichenkette zu verstehen ist. Im Folgenden werden wir uns auf die Formatierung mit
Hilfe von f-Strings beschränken, da sich diese als bevorzugte Methode etabliert hat.</p>
<p>Wir beginnen mit dem einfachsten Fall einer unformatierten Ausgabe.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">3.14159</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.25
1.5 3.14159
</pre></div>
</div>
</div>
</div>
<p>Die Zeile 3, die zur ersten Ausgabezeile führt, zeigt, dass in er
<code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion nicht nur Variablen angeben kann, sondern auch ganze
Ausdrücke, wie hier das Quadrat der Variablen <code class="docutils literal notranslate"><span class="pre">x</span></code>. Daneben ist es möglich,
mehrere Variable gleichzeitig auszugeben. Dazu werden diese im Argument der
<code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion durch ein Komma getrennt. Das Leerzeichen nach dem Komma
ist für Python nicht relevant, verbessert aber die Lesbarkeit des Codes und ist
daher üblich. Auf jeden Fall wird Python in der Ausgabe zwischen den Werten der
beiden Variablen immer ein Leerzeichen setzen.</p>
<p>Um die Bedeutung der ausgegebenen Wert anzudeuten, möchte man häufig gerne noch
einen Text ausgeben. Im einfachsten Fall kann man diesen Text einfach als
weiteres Argument der <code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion in Form einer Zeichenkette
angeben. Zeichenketten werden wir erst im <a class="reference internal" href="sequenzen.html#strings"><span class="std std-numref">Kapitel 6.3</span></a> genauer besprechen.
Für den Moment ist nur wichtig, dass Zeichenketten durch Anführungszeichen
begrenzt werden müssen. Dabei sind sowohl doppelte Anführungszeichen (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>) als
auch einfache Anführungszeichen (<code class="docutils literal notranslate"><span class="pre">'</span></code>) zugelassen, sofern am Anfang und Ende der
Zeichenkette das gleiche Zeichen verwendet wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Näherung für π/3:&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Näherung für π/3: 1.0471966666666666
</pre></div>
</div>
</div>
</div>
<p>Bis jetzt haben wir noch keinerlei Formatierung vorgenommen. Das vorige Beispiel,
bei dem die Kreiszahl nur auf fünf Nachkommastellen einging, illustriert aber,
dass man beispielsweise die Zahl der Nachkommastellen kontrollieren will. In unserem
Beispiel wäre eine Beschränkung auf fünf Nachkommastellen sinnvoll.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Näherung für π/3: </span><span class="si">{</span><span class="n">y</span><span class="o">/</span><span class="mi">3</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Näherung für π/3: 1.04720
</pre></div>
</div>
</div>
</div>
<p>Bevor wir das Vorgehen bei der Formatierung in Python systematischer
diskutieren, sehen wir uns zunächst das Argument der <code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion in
diesem Beispiel genauer an. Durch die Anführungszeichen wird die Zeichenkette
begrenzt die ausgegeben wird. Um diese Zeichenkette als f-String zu kennzeichnen,
muss ein <code class="docutils literal notranslate"><span class="pre">f</span></code> vorangestellt werden. Die eigentliche Zeichenkette enthält zum einen
einfach Text, wobei wir an dem griechischen Buchstaben sehen, dass wir im Prinzip
beliebige Unicodezeichen in UTF-8-Kodierung angeben können.</p>
<p>Daneben enthält die Zeichenkette noch einen Teil, der durch geschweifte Klammern
gekennzeichnet ist, und der eine von Python auszuwertenden Ausdruck sowie eine
Formatierungsangabe enthält, die durch einen Doppelpunkt voneinander getrennt sind.
Der <em>format string</em> lautet hier also <code class="docutils literal notranslate"><span class="pre">.5f</span></code> und gibt mit Hilfe des Buchstabens <code class="docutils literal notranslate"><span class="pre">f</span></code>,
der für <em>float</em> steht, an, dass eine Gleitkommadarstellung gewünscht wird. Die <code class="docutils literal notranslate"><span class="pre">5</span></code>
nach dem Dezimalpunkt legt fest, dass fünf Nachkommastellen auszugeben sind. Wie wir
an der Ausgabe im Beispiel sehen, wird die Zahl nicht einfach abgeschnitten, sondern
gerundet.</p>
<p>In f-Strings ist die Zahl der auszuwertenden Ausdrücke nicht auf einen beschränkt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">power</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">**</span><span class="si">{</span><span class="n">power</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">x</span><span class="o">**</span><span class="n">power</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2**0.5 = 1.4142135623730951
</pre></div>
</div>
</div>
</div>
<p>Hier ist zwischen den zwei Sternchen außerhalb der geschweiften Klammern, die direkt
so ausgegeben werden, und den Sternchen innerhalb der geschweiften Klammern, die als
Exponentierungsoperator fungieren, zu unterscheiden.</p>
<div class="admonition-hinweis admonition">
<p class="admonition-title">Hinweis</p>
<p>Will man im Ausgabetext eine öffnende oder schließende geschweifte Klammer unterbringen,
so ist diese zu verdoppeln, also <code class="docutils literal notranslate"><span class="pre">{{</span></code> oder <code class="docutils literal notranslate"><span class="pre">}}</span></code>.</p>
</div>
<p>Seit Python 3.8 gibt es eine praktische Möglichkeit, sowohl den Namen als auch den
Wert einer Variablen auszugeben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">myvar</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">myvar</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">myvar</span> <span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">myvar</span><span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">myvar</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>myvar = 1.4142135623730951
myvar =1.4142135623730951
myvar= 1.4142135623730951
myvar=1.4142135623730951
</pre></div>
</div>
</div>
</div>
<p>In diesem Beispiel wird deutlich, dass man die Ausgabe von Leerzeichen um das
Gleichheitszeichen herum leicht beeinflussen kann. Für ältere Pythonversionen
müsste man stattdessen den Variablennamen de facto zweimal angeben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;myvar = </span><span class="si">{</span><span class="n">myvar</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>myvar = 1.4142135623730951
</pre></div>
</div>
</div>
</div>
<p>Mit einer Ausnahme haben wir bis jetzt nur Werte von Variablen in einen Text
eingebettet, ohne die Form ihrer Ausgabe zu beeinflussen.  Dies ist aber
beispielsweise bei Gleitkommazahlen wichtig. Wir wollen uns jetzt etwas
systematischer mit den Formatierungsmöglichkeiten beschäftigen.</p>
<p>Bei Gleitkommazahlen ist unter anderem die Anzahl der Nachkommastellen von
Interesse. Um deutlich zu machen, wie viele Leerzeichen ausgegeben werden,
begrenzen wir die Ausgabe mit senkrechten Strichen. In Erweiterung unseres
Beispiels weiter oben, in dem wir fünf Nachkommastellen festgelegt hatten,
wollen wir nun die ganze Breite der Ausgabe festlegen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">6.3f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>| 1.414|
</pre></div>
</div>
</div>
</div>
<p>Von Interesse für uns ist der Bereich zwischen den geschweiften Klammern,
der zunächst den Namen der Variable, also <code class="docutils literal notranslate"><span class="pre">x</span></code>, enthält und, durch einen
Doppelpunkt abgetrennt, die Formatierungsangabe. Die erste Zahl, die auch
aus mehr als einer Ziffer bestehen kann, gibt die gesamte Feldbreite an.
Diese enthält sowohl Vor- und Nachkommastellen als auch den Dezimalpunkt.
Bleibt dann noch Platz, so wird dieser durch Leerzeichen aufgefüllt. Von
der gesamten Feldbreite durch einen Punkt abgetrennt wird die Zahl der
Nachkommastellen angegeben. In unserem Fall benötigt der Wert von <code class="docutils literal notranslate"><span class="pre">x</span></code> eine
Vorkommastelle und drei Nachkommastellen. Zusammen mit dem Dezimalpunkt macht
dies fünf Zeichen, so dass sich noch ein Leerzeichen ergibt. Das abschließend
<code class="docutils literal notranslate"><span class="pre">f</span></code> gibt an, dass der Wert von <code class="docutils literal notranslate"><span class="pre">x</span></code> als Gleitkommazahl ausgegeben werden soll,
also nicht in Exponentialschreibweise.</p>
<p>Wählt man die Feldbreite zu klein, so wird zwar immer noch die gesamte Zahl
ausgegeben, aber untereinanderstehende Zahlen werden unter Umständen nicht
mehr wie gewünscht zueinander ausgerichtet.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">4.3f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|1.414|
</pre></div>
</div>
</div>
</div>
<p>Dies gilt insbesondere, wenn man die Feldbreiten überhaupt nicht spezifiziert,
da dann immer die minimal benötigte Breite belegt wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="o">**</span><span class="mi">7</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.414
11.314
</pre></div>
</div>
</div>
</div>
<p>Bei der Ausrichtung von Zahlen ist auch das Vorzeichen relevant. Hierbei kann
man angeben, wie bei einer positiven Zahl verfahren wird. Durch Eingabe eines
Pluszeichens, eines Leerzeichens oder eines Minuszeichens in der
Formatierungsangabe wird für positive Zahlen ein Plus, ein Leerzeichen bzw. gar
nichts ausgegeben wie die folgenden Beispiele zeigen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">+4.2f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="o">-</span><span class="n">x</span><span class="si">:</span><span class="s2">+4.2f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2"> 4.2f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="o">-</span><span class="n">x</span><span class="si">:</span><span class="s2"> 4.2f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">-4.2f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="o">-</span><span class="n">x</span><span class="si">:</span><span class="s2">-4.2f</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|+1.41|
|-1.41|
| 1.41|
|-1.41|
|1.41|
|-1.41|
</pre></div>
</div>
</div>
</div>
<p>Hier haben wir bewusst die Feldbreite nur auf <code class="docutils literal notranslate"><span class="pre">4</span></code> gesetzt, um den Unterschied
zwischen der dritten und fünften Eingabe zu verdeutlichen.</p>
<p>Bei der Ausgabe von Gleitkommazahlen gibt es nun aber das Problem, dass bei sehr
kleinen oder sehr großen Zahlen eine feste Anzahl von Nachkommastellen nicht
unbedingt geeignet ist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">10.8f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="o">/</span><span class="mf">10e6</span><span class="si">:</span><span class="s2">10.8f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="o">*</span><span class="mf">10e6</span><span class="si">:</span><span class="s2">10.8f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.41421356
0.00000014
14142135.62373095
</pre></div>
</div>
</div>
</div>
<p>Während in der zweiten Zeile die Zahl der ausgegebenen signifikanten Stellen
dramatisch reduziert ist, ist sie in der dritten Zeile unter Umständen
unerwünscht groß. In solchen Fällen bietet es sich an, eine Ausgabe in
Exponentialdarstellung zu verlangen, die man mit Hilfe des Buchstabens <code class="docutils literal notranslate"><span class="pre">e</span></code>
an Stelle des bisherigen <code class="docutils literal notranslate"><span class="pre">f</span></code> erhält.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">10.8e</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">10.4e</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="o">/</span><span class="mf">10e6</span><span class="si">:</span><span class="s2">14.8e</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">20.8e</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|1.41421356e+00|
|1.4142e+00|
|1.41421356e-07|
|      1.41421356e+00|
</pre></div>
</div>
</div>
</div>
<p>Die erste Eingabe zeigt, wie man eine Exponentialdarstellung mit 8
Nachkommastellen erhält. Der Exponent wird mit ausgegeben, obwohl er nur für
<span class="math notranslate nohighlight">\(10^0=1\)</span> steht.  Die Zahl der Nachkommastellen lässt sich, wie erwartet
und wie in der zweiten Eingabe zu sehen ist, bei Bedarf anpassen. In diesem
Beispiel wird die Feldbreite von 10 gerade ausgenutzt. Das dritte Beispiel
zeigt, dass wir nun auch bei der Ausgabe von kleinen Zahlen keine signifikanten
Stellen verlieren. Auch für große Zahlen ändert sich die Zahl der signifikanten
Stellen nicht.  Macht man wie in der vierten Zeile die Feldlänge größer, so wird
entsprechend viel Leerplatz auf der linken Seite ausgegeben.</p>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Um etwas über die Möglichkeiten der Positionierung der Ausgabe
zu erfahren, können Sie im letzten Beispiel folgende Formatspezifikationen
ausprobieren: <code class="docutils literal notranslate"><span class="pre">{:&lt;20.8e}</span></code>, <code class="docutils literal notranslate"><span class="pre">{:=+20.8e}</span></code> und <code class="docutils literal notranslate"><span class="pre">{:^20.8e}</span></code>.</p>
</div>
<p>Häufig möchte man die Exponentialschreibweise nur verwenden, wenn die
auszugebende Zahl hinreichend groß oder klein ist. Ein solches Verhalten
erreicht man durch Angabe des Buchstabens <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="o">/</span><span class="mf">10e4</span><span class="si">:</span><span class="s2">15.8g</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="o">/</span><span class="mf">10e3</span><span class="si">:</span><span class="s2">15.8g</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="o">*</span><span class="mf">10e6</span><span class="si">:</span><span class="s2">15.8g</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">x</span><span class="o">*</span><span class="mf">10e7</span><span class="si">:</span><span class="s2">15.8g</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|  1.4142136e-05|
|  0.00014142136|
|       14142136|
|  1.4142136e+08|
</pre></div>
</div>
</div>
</div>
<p>Hier wird durch den Wechsel der Darstellung insbesondere sichergestellt, dass
immer die gleiche Anzahl von signifikanten Stellen ausgegeben wird.  Die genaue
Regel für die Umstellung der Darstellungsart kann man in der Dokumentation der
Python-Standardbibliothek unter dem Thema <a class="reference external" href="http://docs.python.org/3/library/string.html#formatspec">Format Specification
Mini-Language</a>
nachlesen, die auch alle weiteren Aspekte der Formatierung detailliert beschreibt.</p>
<p>Betrachten wir nun noch die Formatierung von Integers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">42</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">05</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|42|   42|00042|
</pre></div>
</div>
</div>
</div>
<p>Integers in Dezimaldarstellung benötigen keinen Buchstaben zur
Formatspezifikation. Man kann aber ein <code class="docutils literal notranslate"><span class="pre">d</span></code> für Dezimaldarstellung angeben.
Ähnlich wie bei den Gleitkommazahlen lässt sich die Feldbreite festlegen. Gibt
man vor der Feldbreite eine Null an, so wird das Feld vor der auszugebenden
Zahl mit Nullen aufgefüllt. Dies kann zum Beispiel bei der Ausgabe in anderen
Zahlensystemen interessant sein. Python unterstützt insbesondere die Ausgabe im
Binärformat (<code class="docutils literal notranslate"><span class="pre">b</span></code>), Oktalformat (<code class="docutils literal notranslate"><span class="pre">o</span></code>) und im Hexadezimalformat (<code class="docutils literal notranslate"><span class="pre">x</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;|</span><span class="si">{</span><span class="n">n</span><span class="si">:}</span><span class="s2">|</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">8b</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">8o</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">8x</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">08b</span><span class="si">}</span><span class="s2">|&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|42|  101010|      52|      2a|00101010|
</pre></div>
</div>
</div>
</div>
<div class="admonition-frage admonition">
<p class="admonition-title">Frage</p>
<p>Was ändert sich, wenn man <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">o</span></code> und <code class="docutils literal notranslate"><span class="pre">x</span></code> durch die entsprechenden
Großbuchstaben ersetzt? Welche Auswirkungen hat ein <code class="docutils literal notranslate"><span class="pre">#</span></code>, das vor der Feldbreite
inklusive einer eventuell vorhandenen Null steht?</p>
</div>
<p>Abschließend sei noch angemerkt, dass die <code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code>-Funktion standardmäßig
einen Zeilenumbruch an das Ende des auszugebenden Textes anhängt. Dies ist
jedoch nicht immer gewünscht und lässt sich mit Hilfe der Option <code class="docutils literal notranslate"><span class="pre">end</span></code>
beeinflussen. Folgendes Beispiel zeigt die Funktionsweise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;..&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x..xx
</pre></div>
</div>
</div>
</div>
<p>Aufgrund der ersten Zeile werden zwei Punkte an das <code class="docutils literal notranslate"><span class="pre">x</span></code> angehängt, ohne einen
Zeilenumbruch zu verursachen. Letzteres wird auch in der zweiten Zeile vermieden.
Es werden wegen der leeren Zeichenkette (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>) aber keine weiteren Zeichen an das zweite
<code class="docutils literal notranslate"><span class="pre">x</span></code> angehängt. In der dritten Zeile schließlich wird ein weiteres <code class="docutils literal notranslate"><span class="pre">x</span></code> angehängt.
Zusätzlich wird ein Zeilenumbruch erzeugt, da das Argument <code class="docutils literal notranslate"><span class="pre">end</span></code> nicht gesetzt wurde.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="vorschau.html" title="previous page"><span class="section-number">2. </span>Eine Vorschau</a>
    <a class='right-next' id="next-link" href="kontrollstrukturen.html" title="next page"><span class="section-number">4. </span>Kontrollstrukturen</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Gert-Ludwig Ingold<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>