
<!DOCTYPE html>

<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4. Kontrollstrukturen &#8212; Einführung in Prinzipien der Programmierung</title>
    
  <link rel="stylesheet" href="_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="5. Funktionen" href="funktionen.html" />
    <link rel="prev" title="3. Einfache Datentypen, Variablen und Zuweisungen" href="datentypen.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  
  <h1 class="site-logo" id="site-title">Einführung in Prinzipien der Programmierung</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Dieses Buch durchsuchen ..." aria-label="Dieses Buch durchsuchen ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="einleitung.html">
   1. Einleitung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="vorschau.html">
   2. Eine Vorschau
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="datentypen.html">
   3. Einfache Datentypen, Variablen und Zuweisungen
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   4. Kontrollstrukturen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="funktionen.html">
   5. Funktionen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sequenzen.html">
   6. Zusammengesetzte Datentypen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="einausgabe.html">
   7. Ein- und Ausgabe
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="scipy.html">
   8. Numerische Programmbibliotheken am Beispiel von NumPy/SciPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="objektorientiert.html">
   9. Objektorientiertes Programmieren
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="grafik.html">
   10. Erstellung von Grafiken
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zahlensysteme.html">
   11. Anhang: Zahlensysteme
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="floats.html">
   12. Anhang: 64-Bit-Gleitkommazahlen nach IEEE-Standard 754
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="unicode.html">
   13. Anhang: Unicode
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Navigation umschalten" aria-controls="site-navigation"
            title="Navigation umschalten" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Laden Sie diese Seite herunter"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="_sources/kontrollstrukturen.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Notebook-Datei herunterladen" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/kontrollstrukturen.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Quelldatei herunterladen" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="In PDF drucken"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Vollbildmodus"
                title="Vollbildmodus"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/gertingold/epriprog/master?urlpath=tree/epriprog/kontrollstrukturen.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Starten Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Inhalt
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#for-schleife">
   4.1. For-Schleife
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#while-schleife">
   4.2. While-Schleife
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#verzweigungen">
   4.3. Verzweigungen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#abfangen-von-ausnahmen">
   4.4. Abfangen von Ausnahmen
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="kontrollstrukturen">
<h1><span class="section-number">4. </span>Kontrollstrukturen<a class="headerlink" href="#kontrollstrukturen" title="Link zu dieser Überschrift">¶</a></h1>
<p>Im <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> hatten wir bereits kurz die Möglichkeit angesprochen, den
Ablauf eines Programms zu beeinflussen, sei es dadurch, dass ein Programmteil
in einer Schleife mehrfach ausgeführt wird oder dass ein Programmteil nur dann
ausgeführt wird, wenn eine gewisse Bedingung erfüllt ist.  Solche
Kontrollstrukturen sind essentiell, um die Abarbeitung eines Programms zu
steuern. Wir werden in diesem Kapitel zwei Arten von Schleifen betrachten, die
<code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife und die <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife, bei denen auf verschiedene Weise die
Zahl der Schleifendurchläufe kontrolliert wird. Anschließend werden wir uns mit
Verzweigungen der Form <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">…</span> <span class="pre">else</span></code> beschäftigen und auch komplexere
Verzweigungen kennenlernen. Diese Programmkonstrukte finden sich in allen für
das wissenschaftliche Rechnen relevanten Programmiersprachen, auch wenn die
konkrete syntaktische Umsetzung unterschiedlich sein kann.</p>
<p>Wir hatten im vorigen Kapitel bereits gesehen, dass im Fehlerfall, zum Beispiel
bei der Division durch Null, Ausnahmen oder <em>exceptions</em> auftreten. Diese müssen
nicht zwingend zum Abbruch des Programms führen, sondern sie können geeignet
behandelt werden. Diesen Aspekt der Steuerung des Programmablaufs werden wir im
letzten Abschnitt dieses Kapitels kennenlernen.</p>
<div class="section" id="for-schleife">
<span id="forloop"></span><h2><span class="section-number">4.1. </span>For-Schleife<a class="headerlink" href="#for-schleife" title="Link zu dieser Überschrift">¶</a></h2>
<p>Sollen bestimmte Anweisungen mehrfach ausgeführt werden, wobei die Anzahl der
Wiederholungen zuvor bestimmt werden kann, bietet sich die Verwendung einer
<code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife an. Gegenüber der expliziten Wiederholung von Befehlen ergeben
sich eine Reihe von Vorteilen. Zunächst einmal spart man sich Tipparbeit und
verbessert erheblich die Lesbarkeit des Programms. Zudem ist eine explizite
Wiederholung nur möglich, wenn die Zahl der Wiederholungen bereits beim
Schreiben des Programms feststeht und nicht erst beim Ausführen des Programms
berechnet wird.</p>
<p>Wir verdeutlichen das anhand eines Beispiels, in dem wir einige Quadratzahlen
berechnen. In einer <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife würde das für die Zahlen von 0 bis 4
folgendermaßen gehen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>   0    0
   1    1
   2    4
   3    9
   4   16
</pre></div>
</div>
</div>
</div>
<p>Verzichtet man auf die Schleife, so wäre der folgende Code erforderlich.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">0</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="mi">0</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">1</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="mi">1</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">3</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">4</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="mi">4</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>   0    0
   1    1
   2    4
   3    9
   4   16
</pre></div>
</div>
</div>
</div>
<p>Es dürfte offensichtlich sein, dass die erste Variante zu bevorzugen ist.
Dies gilt insbesondere, wenn die Zahl der Durchläufe variable sein soll, wie
im folgenden Fall.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nmax</span> <span class="o">=</span> <span class="mi">7</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">4</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>   0    0
   1    1
   2    4
   3    9
   4   16
   5   25
   6   36
</pre></div>
</div>
</div>
</div>
<p>Sehen wir uns den Aufbau der <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife genauer an. Das Schlüsselwort <code class="docutils literal notranslate"><span class="pre">for</span></code>
kennzeichnet den Beginn einer Schleife. Dann folgt der Name der Variable, in
unserem Fall also <code class="docutils literal notranslate"><span class="pre">n</span></code>, die bei der Abarbeitung der Schleife vorgegebene Werte
annimmt, und im Rahmen der Schleife verwendet werden kann. Im Allgemeinen
können hier auch mehrere Variablennamen vorkommen, wie wir später im
<a class="reference internal" href="sequenzen.html#zusgdatentypen"><span class="std std-numref">Kapitel 6</span></a> sehen werden. Die Werte, die die Variable <code class="docutils literal notranslate"><span class="pre">n</span></code> in
unserem Beispiel annehmen kann, werden durch die <code class="docutils literal notranslate"><span class="pre">range</span></code>-Anweisung bestimmt.
Zwar werden die Werte erst bei Bedarf generiert, aber wir können sie uns
ansehen, indem wir explizit eine Liste der Werte erzeugen lassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 1, 2, 3, 4]
</pre></div>
</div>
</div>
</div>
<p>Es wird also eine Liste von aufeinanderfolgenden ganzen Zahlen erzeugt, die
hier fünf Elemente enthält. Zu beachten ist, dass die Liste mit Null beginnt
und nicht mit Eins. Wir werden uns diesen zusammengesetzten Datentyp im
<a class="reference internal" href="sequenzen.html#listen"><span class="std std-numref">Kapitel 6.1</span></a> noch genauer ansehen. Für den Moment genügt jedoch die
intuitive Vorstellung von einer Liste. In der ersten Zeile der
<code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife, die mit einem Doppelpunkt enden muss, wird also festgelegt,
welchen Wert die Schleifenvariable <code class="docutils literal notranslate"><span class="pre">n</span></code> bei den aufeinanderfolgenden
Schleifendurchläufen jeweils annimmt.</p>
<div class="tip admonition">
<p class="admonition-title">Mehr Flexibilität in der range()-Funktion</p>
<p>Mit nur einem Argument erzeugt die <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion wie oben gesehen
ganze Zahlen von 0 bis ausschließlich dem angegebenen Wert. Gibt man zwei
Argumente an, so entsprechen diese dem Startwert und dem Wert, der gerade
nicht mehr angenommen wird. Gibt man ein drittes Argument an, so entspricht
dieses der Schrittweite, die übrigens auch negativ sein kann. Alle Argumente
müssen aber ganze Zahlen sein. Spielen Sie einfach mal ein bisschen mit
der <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion herum.</p>
</div>
<p>Der Codeteil, der im Rahmen der Schleife im Allgemeinen mehrfach ausgeführt
wird und im obigen Beispiel nur aus einer Zeile besteht, ist daran zu erkennen,
dass er eingerückt ist. Zur Verdeutlichung vergleichen wir zwei Beispiele,
die sich lediglich in der Einrückung der letzten Zeile unterscheiden.
Im ersten Beispiel ist die letzte Zeile Bestandteil der Schleife und wird
demnach zweimal ausgeführt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Schleifendurchlauf </span><span class="si">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Das war&#39;s.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Schleifendurchlauf 1
Das war&#39;s.
Schleifendurchlauf 2
Das war&#39;s.
</pre></div>
</div>
</div>
</div>
<p>Rückt man die letzte Zeile dagegen aus, so wird sie erst ausgeführt nachdem
die Schleife zweimal durchlaufen wurde.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Schleifendurchlauf </span><span class="si">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Das war&#39;s.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Schleifendurchlauf 1
Schleifendurchlauf 2
Das war&#39;s.
</pre></div>
</div>
</div>
</div>
<p>Im vorliegenden Beispiel ist sicher die zweite Variante adäquat.</p>
<p>Entscheidend für die Zugehörigkeit zur Schleife ist also die Einrückung, wobei
die Zahl der Leerstellen im Prinzip frei gewählt werden kann, aber innerhalb
des ganzen Schleifenkörpers konstant sein muss. Ein guter Kompromiss zwischen
kaum sichtbaren Einrückungen und zu großen Einrückungen, die bei geschachtelten
Schleifen schnell zu Platzproblemen führen, ist eine Einrückung von vier
Leerzeichen. So wird dies auch im <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> empfohlen, dem <em>Python Enhancement
Proposal</em>, das Empfehlungen zur Formatierung von in Python geschriebenem
Programmcode gibt. Diese Empfehlungen sind zwar nicht verpflichtend, aber die
wichtigsten Hinweise werden von den meisten Programmierern respektiert.</p>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Im <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> wird auch eine maximale Zeilenlänge von 79 Zeichen empfohlen. Sehr
lange Zeilen sind unter Umständen schwer zu lesen und führen bei kleineren
Bildschirmen zu Problemen mit Zeilenumbrüchen. Da heutzutage oft größere
Monitore zum Einsatz kommen, geben manche Projekte eine Maximallänge von 99
Zeichen vor.</p>
</div>
<p>Da die Verwendung der Einrückung als syntaktisches Merkmal ungewöhnlich ist,
wollen wir kurz zwei Beispiele aus anderen Programmiersprachen besprechen. In
FORTRAN 90 könnte eine Schleife folgendermaßen aussehen:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">Quadrat</span>
<span class="k">DO </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span>
   <span class="k">PRINT</span> <span class="s1">&#39;(2I4)&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span>
<span class="k">END DO</span>
<span class="k">END PROGRAM </span><span class="n">Quadrat</span>
</pre></div>
</div>
<p>Hier wurde nur aus Gründen der Lesbarkeit eine Einrückung vorgenommen. Relevant
für das Ende der Schleife ist lediglich das abschließende <code class="docutils literal notranslate"><span class="pre">END</span> <span class="pre">DO</span></code>. Während
man sich hier selbst dazu zwingen muss, gut lesbaren Code zu schreiben, zwingt
Python den Programmierer durch seine Syntax dazu, übersichtlichen Code zu
produzieren.</p>
<p>Auch im folgenden C-Code sind die Einrückungen nur der Lesbarkeit wegen
vorgenommen worden. Der Inhalt der Schleife wird durch die öffnende
geschweifte Klammer in Zeile 6 und die schließende geschweifte Klammer in Zeile
9 definiert.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">main</span><span class="p">(){</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">quadrat</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="hll">         <span class="n">quadrat</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span>         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%4i %4i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">quadrat</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Würde man auf die Klammern verzichten, so wäre nur die der <code class="docutils literal notranslate"><span class="pre">for</span></code>-Anweisung folgende
Zeile, also Zeile 7, Bestandteil der Schleife. Dagegen befände sich Zeile 8 trotz
der Einrückung nicht mehr im Schleifenkörper.</p>
<p>Schleifen werden in Python häufig anders organisiert als dies in Sprachen wie
Fortran und C der Fall ist. Diesen Unterschied können wir durch zwei
Realisierungen der gleichen Problemstellung illustrieren. Im <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a>
hatten wir eine Implementation des Schere-Papier-Stein-Spiels in Python
besprochen. Darin kam unter anderem eine Liste der drei beteiligten Gegenstände
vor. An dieser Stelle ist nur wichtig, dass wir Elemente einer Liste durch
einen Index adressieren können, so wie wir das für die Komponenten eines
Vektors in der Mathematik gewohnt sind.</p>
<p>Stellen wir uns nun vor, dass wir eine Liste der drei Gegenstände ausgeben wollen.
Eine erste Variante besteht darin, mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion eine Schleife
über die Indizes zu programmieren, in der dann die Elemente der Liste adressiert und
ausgegeben werden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">objekte</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Stein&#39;</span><span class="p">,</span> <span class="s1">&#39;Papier&#39;</span><span class="p">,</span> <span class="s1">&#39;Schere&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">objekte</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Stein
Papier
Schere
</pre></div>
</div>
</div>
</div>
<p>Eine solche Vorgehensweise ist für Sprachen wie Fortran und C typisch. Da der
Index in gleichmäßigen Schritten hochgezählt wird, ist es für den Computer möglich,
effizient auf die einzelnen Listenobjekte zuzugreifen. Dies gilt insbesondere, wenn
es sich bei den Listenobjekten um Zahlen handelt, die alle gleich viel Speicher
in Anspruch nehmen. Diese erste Variante wird in Python eigentlich nur in besonderen
Fällen verwendet, in denen die Rechengeschwindigkeit im Vordergrund steht.</p>
<p>In Python üblicher ist die zweite Variante, bei der direkt über die Liste iteriert
wird.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">objekt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Stein&#39;</span><span class="p">,</span> <span class="s1">&#39;Papier&#39;</span><span class="p">,</span> <span class="s1">&#39;Schere&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">objekt</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Stein
Papier
Schere
</pre></div>
</div>
</div>
</div>
<p>Aus der zweiten Zeile wird hier offensichtlich, dass die Schleife über alle Elemente
der Liste geht. Der Code ist insgesamt etwas leichter zu lesen und schneller zu
schreiben als der Code der ersten Variante und wird daher normalerweise von
Python-Programmierern bevorzugt.</p>
<p>Wir betrachten noch ein zweites Beispiel, das von seiner Struktur gerade beim
numerischen Arbeiten typisch ist. Dabei wollen wir die Kreiszahl π mit Hilfe
der Summendarstellung</p>
<div class="math notranslate nohighlight">
\[\sum_{n=1}^\infty\frac{1}{n^2} = \frac{\pi^2}{6}\]</div>
<p>bestimmen. Dies geht allein schon deshalb nur näherungsweise, weil wir die Summe
bei einem wählbaren maximalen Index abschneiden müssen. Dabei fällt der Fehler
invers linear mit diesem maximalen Index. Betrachten wir nun den zugehörigen Python-Code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">nmax</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">summe</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">summe</span> <span class="o">=</span> <span class="n">summe</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">summe</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.141583104326456
</pre></div>
</div>
</div>
</div>
<p>Den maximalen Summationsindex hätten wir hier auch direkt in das Argument der
<code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion schreiben können. Wollen wir diesen Wert aber ändern, so
ist die betreffende Stelle leichter zu finden, da der Variablenname <code class="docutils literal notranslate"><span class="pre">nmax</span></code> auf
die Bedeutung dieses Wert hinweist.</p>
<p>Zwei Aspekte wollen wir an diesem Beispiel betonen. Zum einen übersieht man leicht,
dass im Nenner nicht einfach <code class="docutils literal notranslate"><span class="pre">n**2</span></code> stehen darf. Dies würde zu einer Division durch
Null führen, da der erste Wert, der von der <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion geliefert wird,
gerade Null ist. Da die Summation bei 1 beginnt, müssen wir also im Nenner <code class="docutils literal notranslate"><span class="pre">(n+1)**2</span></code>
schreiben.</p>
<p>Ein zweiter Aspekt wird gerne übersehen. Im Schleifenkörper, der hier nur aus der
vorletzten Zeile besteht, wird wie bei jeder Zuweisung zunächst die rechte Seite
ausgewertet. Dabei erwartet der Pythoninterpreter schon beim ersten Durchlauf, dass
die Variable <code class="docutils literal notranslate"><span class="pre">summe</span></code> einen Wert besitzt. Auch wenn wir einen fehlenden Wert intuitiv
einfach auf Null setzen würden, ist es für Python ein großer Unterschied, ob eine
Variable den Wert Null hat oder überhaupt keinen Wert besitzt. Dies bedeutet, dass
unser Beispiel nicht mehr läuft, wenn wir die vierte Zeile weglassen. Aus technischen
Gründen entfernen wir die Variable hier explizit, da sie sonst ihren Wert aus der
obigen Zelle behält.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">summe</span>
</pre></div>
</div>
</div>
</div>
<p>Unser neuer Code hat nun die folgende Form.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">nmax</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">summe</span> <span class="o">=</span> <span class="n">summe</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">summe</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">3</span><span class="n">f25c651cbec</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">nmax</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
<span class="ne">----&gt; </span><span class="mi">5</span>     <span class="n">summe</span> <span class="o">=</span> <span class="n">summe</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span> <span class="nb">print</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">summe</span><span class="p">))</span>

<span class="ne">NameError</span>: name &#39;summe&#39; is not defined
</pre></div>
</div>
</div>
</div>
<p>Wie erwartet schlägt die Ausführung fehl, weil die Variable <code class="docutils literal notranslate"><span class="pre">summe</span></code> beim allerersten
Schleifendurchlauf noch nicht definiert ist. Es ist also unbedingt erforderlich,
die Variable vor der Schleife zu definieren. Man spricht hier auch von einer
Initialisierung.</p>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleifen können auch geschachtelt werden. Wir zeigen dies an einem Beispiel,
das die Wahrheitswerttabelle für die logische UND-Verknüpfung (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) und die logische
ODER-Verknüpfung (<code class="docutils literal notranslate"><span class="pre">|</span></code>) darstellt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  arg1   arg2   arg1 &amp; arg2   arg1 | arg2 &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------------------------------------&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">arg1</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">arg2</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">arg1</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">&amp;</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">|</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  arg1   arg2   arg1 &amp; arg2   arg1 | arg2 
------------------------------------------
 False  False      False         False   
 False  True       False         True    
 True   False      False         True    
 True   True       True          True    
</pre></div>
</div>
</div>
</div>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Unter anderem für solche Situationen stellt in Python das
<a class="reference external" href="https://docs.python.org/3/library/itertools.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code>-Modul</a> der
Standardbibliothek hilfreiche Funktionen zur Verfügung.</p>
</div>
<p>Wie man in den ersten beiden Spalten der Ausgabe sieht, wird zunächst in der äußeren
Schleife <code class="docutils literal notranslate"><span class="pre">arg1</span></code> auf <code class="docutils literal notranslate"><span class="pre">False</span></code> gesetzt. Anschließend wird die innere Schleife abgearbeitet,
in der <code class="docutils literal notranslate"><span class="pre">arg2</span></code> nacheinander die Werte <code class="docutils literal notranslate"><span class="pre">False</span></code> und <code class="docutils literal notranslate"><span class="pre">True</span></code> annimmt. Erst dann wird in der
äußeren Schleife <code class="docutils literal notranslate"><span class="pre">arg1</span></code> auf <code class="docutils literal notranslate"><span class="pre">True</span></code> gesetzt und danach wiederum die innere Schleife
abgearbeitet.</p>
<p>Gerade in einer doppelten Schleife ist die Einrückung wichtig, die darüber bestimmt,
in welcher Schleife eine Befehlszeile abgearbeitet wird. Da die <code class="docutils literal notranslate"><span class="pre">print</span></code>-Anweisung
relativ zur inneren Schleife eingerückt ist, wird sie in dieser ausgeführt. und
entsprechend werden zusätzlich zum Tabellenkopf vier Zeile ausgegeben. Würde man die
letzte Zeile nur vier Leerzeichen weit einrücken, würde sie in die äußere Schleife
wandern und nur zweimal ausgeführt werden.</p>
<p>Versucht man dies, gibt es zunächst allerdings ein Problem.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  arg1   arg2   arg1 &amp; arg2   arg1 | arg2 &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------------------------------------&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">arg1</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">arg2</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">arg1</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">&amp;</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">|</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-13-796f5cfb3843&gt;&quot;</span><span class="gt">, line </span><span class="mi">5</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">arg1</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">&amp;</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">|</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="o">^</span>
<span class="ne">IndentationError</span>: expected an indented block
</pre></div>
</div>
</div>
</div>
<p>Jede Schleife erwartet nämlich einen eingerückten Block von mindestens einer Zeile
Länge. In unserem Fall ist es eigentlich nicht sinnvoll, die innere Schleife leer
zu lassen. Gerade bei der Programmentwicklung kann es aber vorkommen, dass man eine
Schleife schon mal anlegen, aber erst später mit Code füllen will. Häufiger kommt
dies bei Funktionen vor, in denen sich das gleiche Problem stellt. Dann hilft der
Befehl <code class="docutils literal notranslate"><span class="pre">pass</span></code> weiter, der Python signalisiert, dass es hier nichts zu tun gibt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  arg1   arg2   arg1 &amp; arg2   arg1 | arg2 &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------------------------------------&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">arg1</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">arg2</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
        <span class="k">pass</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">arg1</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">5</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">&amp;</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">arg1</span><span class="o">|</span><span class="n">arg2</span><span class="si">!s:</span><span class="s2">^11</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  arg1   arg2   arg1 &amp; arg2   arg1 | arg2 
------------------------------------------
 False  True       False         True    
 True   True       True          True    
</pre></div>
</div>
</div>
</div>
<p>Jetzt wird die <code class="docutils literal notranslate"><span class="pre">print</span></code>-Anweisung tatsächlich nur zweimal ausgeführt, nämlich jeweils
am Ende der Abarbeitung der äußeren Schleifendurchläufe. Außerdem kann man hier
noch feststellen, dass die Laufvariable <code class="docutils literal notranslate"><span class="pre">arg2</span></code> der inneren Schleife auch nach der
Abarbeitung der Schleife zur Verfügung steht. Sie hat dabei den Wert, der ihr zuletzt
zugewiesen wurde, in unserem Fall also <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</div>
<div class="section" id="while-schleife">
<h2><span class="section-number">4.2. </span>While-Schleife<a class="headerlink" href="#while-schleife" title="Link zu dieser Überschrift">¶</a></h2>
<p>Bei der gerade besprochenen <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife kennt man im Vorhinein die Zahl der
Durchläufe. Dies ist jedoch nicht immer der Fall. Gelegentlich möchte man eine
Schleife ausführen, so lange eine bestimmte Bedingung erfüllt ist. Einen eher
untypischen Fall hatten wir in <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> kennengelernt. Dort war die
Bedingung immer wahr, so dass die Schleife, zumindest im Prinzip, unendlich
lange laufen konnte. In unserem Beispiel wollen wir dagegen eine Bedingung
stellen, die entweder wahr oder falsch sein kann.</p>
<p>Konkret wollen wir uns vorstellen, dass wir mit einem Würfel so lange würfeln
bis wir eine Sechs erhalten. Wir wollen uns fragen, wie lange es im Mittel
dauert, bis wir eine Sechs gewürfelt haben und welche Wurfanzahl die häufigste
ist. Diese Fragen lassen sich mathematisch streng beantworten, aber wir wollen
nun den Computer heranziehen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">wait_for_six</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">ncasts</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">ncasts</span> <span class="o">=</span> <span class="n">ncasts</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ncasts</span>

<span class="n">waiting_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">wait_for_six</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">waiting_sequence</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/kontrollstrukturen_29_0.png" src="_images/kontrollstrukturen_29_0.png" />
</div>
</div>
<p>Bei der Besprechung des Codes wollen wir uns auf die Funktion <code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for_six()</span></code>
konzentrieren, die die <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife enthält und für eine zufällige Realisierung
von Würfen bestimmt, wie viele Würfe benötigt werden um zum ersten Mal eine Sechs
zu erhalten.</p>
<p>Betrachten wir zunächst einmal die grundsätzliche Struktur des Codes innerhalb
der Funktion. Ähnlich wie bei einem der Beispiele für eine <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife im
vorigen Kapitel  wird zunächst eine Initialisierung vorgenommen. Dazu wird mit
Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">randrange()</span></code>-Funktion ein Würfelwurf mit einem Ergebnis zwischen
1 und 6 vorgenommen. Anhand des Werts der Variable <code class="docutils literal notranslate"><span class="pre">result</span></code> wird nachher festgelegt,
über noch weitere Würfe erforderlich sind. Außerdem müssen wir die Zahl der Würfe
zählen. Da bereits ein Wurf stattgefunden hat, setzen wir die betreffende Variable
<code class="docutils literal notranslate"><span class="pre">ncasts</span></code> auf Eins. Nun beginnt die Schleife mit dem Schlüsselwort <code class="docutils literal notranslate"><span class="pre">while</span></code>, das von
einer Bedingung gefolgt wird, die wiederum mit einem Doppelpunkt abgeschlossen wird.
Die folgenden, zum Schleifenkörper gehörenden Zeilen sind wie üblich eingerückt. Bis
auf das Schlüsselwort <code class="docutils literal notranslate"><span class="pre">while</span></code> entspricht die Struktur also dem, was wir von der
<code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife schon kennen.</p>
<p>In der <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife wird zu Beginn getestet, ob die Befehle im Schleifenkörper
überhaupt abgearbeitet werden sollen. Dies ist genau dann der Fall, wenn die
Bedingung erfüllt ist, in unserem Fall also wenn <code class="docutils literal notranslate"><span class="pre">result</span></code> nicht den Wert 6 besitzt.
Dann muss offenbar weitergewürfelt werden. Andernfalls wird der Schleifenkörper
übersprungen und die Ausführung wird der ersten nicht mehr eingerückten Anweisung
fortgesetzt. In unserem Fall wird dann die Zahl der Würfe an den aufrufenden Code
zurückgegeben. Im Schleifenkörper selbst wird gewürfelt und der Wurfzähler um
Eins erhöht. Anschließend wird wieder getestet, ob <code class="docutils literal notranslate"><span class="pre">result</span></code> ungleich 6 ist und
gegebenenfalls die Ausführung der Schleife fortgesetzt.</p>
<p>Aufmerksamen Leserinnen und Lesern fällt in diesem Code vielleicht auf, dass der
Code für das Würfeln wiederholt wird. Am Ende von <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> hatten wir
darauf angewiesen, dass in solchen Fällen die Gefahr von Programmierfehlern droht.
Dies könnte beispielsweise der Fall sein, wenn man statt für einen normalen Würfel
das Programm auf einen der in <a class="reference internal" href="#fig-wuerfel"><span class="std std-numref">Abb. 4.1</span></a> gezeigten Würfel mit 12 oder 20
Flächen übertragen möchte. Dann kann es passieren, dass man aus Versehen nur einen
der beiden Aufrufe der <code class="xref py py-func docutils literal notranslate"><span class="pre">randrange()</span></code>-Funktion korrigiert, womit das Programm
fehlerhaft wäre.</p>
<div class="figure align-default" id="fig-wuerfel">
<a class="reference internal image-reference" href="_images/wuerfel.png"><img alt="_images/wuerfel.png" src="_images/wuerfel.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-number">Abb. 4.1 </span><span class="caption-text">Dodekaeder- und Ikosaederwürfel.</span><a class="headerlink" href="#fig-wuerfel" title="Link zu diesem Bild">¶</a></p>
</div>
<p>Der Grund für den ersten Aufruf der <code class="xref py py-func docutils literal notranslate"><span class="pre">randrange()</span></code>-Funktion besteht darin,
dass bei der Ausführung des Bedingung zu Beginn der <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife die
Variable <code class="docutils literal notranslate"><span class="pre">result</span></code> bekannt sein muss. Ein möglicher Ausweg besteht darin, den
Wert von <code class="docutils literal notranslate"><span class="pre">result</span></code> so zu setzen, dass die Bedingung beim ersten Mal auf jeden
Fall wahr ist. Dazu können wir <code class="docutils literal notranslate"><span class="pre">result</span></code> zum Beispiel gleich Null setzen. Da wir
damit noch nicht gewürfelt haben, setzen wir auch <code class="docutils literal notranslate"><span class="pre">ncasts</span></code> gleich Null. Nun
finden alle Würfe innerhalb der <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife statt. Der folgende Code verwendet
die <code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for_six()</span></code>-Funktion, um die mittlere Zahl der Würfe zu bestimmen,
die benötigt werden, um eine 6 zu erhalten. Aufgrund der endlichen Zahl von
Realisierungen ist es nicht unerwartet, dass das Ergebnis vom analytischen Ergebnis,
nämlich 6, etwas abweicht.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>

<span class="k">def</span> <span class="nf">wait_for_six</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ncasts</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">result</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="n">ncasts</span> <span class="o">=</span> <span class="n">ncasts</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ncasts</span>

<span class="n">waiting_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">wait_for_six</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)]</span>
<span class="n">average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">waiting_sequence</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">waiting_sequence</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">average</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.98425
</pre></div>
</div>
</div>
</div>
<p>Im Prinzip ließe sich unser Problem eleganter lösen, wenn man die Bedingung nicht
zu Beginn der <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife überprüfen würde, sondern an deren  Ende. Dann würde die
Schleife auf jeden Fall einmal durchlaufen werden. In Python ist dies nicht direkt
möglich, so dass wir zu dieser Hilfslösung greifen mussten. In anderen Sprachen gibt
es dagegen ein <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">…</span> <span class="pre">while</span></code>, wie zum Beispiel in C, oder ein <code class="docutils literal notranslate"><span class="pre">repeat</span> <span class="pre">…</span> <span class="pre">until</span></code> wie in
Pascal. Dabei wird am Ende getestet.</p>
<p>Ein einfaches Beispiel, das im Prinzip eine absteigende Folge von Quadratzahlen
ausgibt, ist hier in C realisiert.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>
   <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">-1</span><span class="p">;</span>
   <span class="k">do</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%4i %4i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
       <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="mi">-1</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Nach der Kompilation des Codes kann man das Programm ausführen und erhält als Ausgabe</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">-</span><span class="mi">1</span>    <span class="mi">1</span>
</pre></div>
</div>
<p>In Zeile 4 wird der Wert von <code class="docutils literal notranslate"><span class="pre">i</span></code> auf <code class="docutils literal notranslate"><span class="pre">-1</span></code> gesetzt. Würde die Bedingung <code class="docutils literal notranslate"><span class="pre">i&gt;0</span></code> schon zu
Beginn der Schleife ausgewertet werden, würde man keine Ausgabe erhalten. Im vorliegenden
Code erfolgt die Überprüfung aber am Ende, so dass die Schleife für den Wert <code class="docutils literal notranslate"><span class="pre">-1</span></code> für <code class="docutils literal notranslate"><span class="pre">i</span></code>
durchlaufen wird. Anschließend hat <code class="docutils literal notranslate"><span class="pre">i</span></code> den Wert <code class="docutils literal notranslate"><span class="pre">-2</span></code> und die Schleife wird beendet. Hier
sei nochmals angemerkt, dass die Einrückungen in C nicht erforderlich sind, sondern dass
stattdessen die geschweiften Klammerpaare relevant sind.</p>
<p>Entsprechend funktioniert das <code class="docutils literal notranslate"><span class="pre">repeat</span> <span class="pre">…</span> <span class="pre">until</span></code>-Konstrukt in Pascal.</p>
<div class="highlight-pascal notranslate"><div class="highlight"><pre><span></span><span class="k">program</span> <span class="n">Quadrat</span><span class="o">;</span>
<span class="k">var</span>
  <span class="n">i</span><span class="o">:</span> <span class="kt">integer</span><span class="o">;</span>
<span class="k">begin</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

  <span class="k">repeat</span>
    <span class="nb">writeln</span><span class="p">(</span><span class="n">i</span><span class="o">,</span> <span class="s">&#39;   &#39;</span><span class="o">,</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">;</span>
    <span class="n">i</span> <span class="o">:=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="k">until</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>

<span class="k">end</span><span class="o">.</span>
</pre></div>
</div>
<p>Einen Unterschied gibt es im Verhalten, wenn die angegebene Bedingung erfüllt ist. Im
C-Beispiel wird die Schleife dann fortgesetzt, während sie im Pascal-Beispiel beendet
wird. Entsprechend sind die beiden Bedingungen verschieden formuliert.</p>
<p>Abschließend sei betont, dass der Programmierer bei der Verwendung von
<code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleifen und ähnlichen Konstrukten selbst dafür verantwortlich
ist sicherzustellen, dass die Schleife irgendwann beendet wird.
Andernfalls liegt eine Endlosschleife vor und das Programm muss von außen
abgebrochen werden. Dieses Szenario kann allerdings gezielt bei Programmen
eingesetzt werden, die durch äußere Ereignisse wie Tastendrucke oder Mausbewegungen
gesteuert werden. Ein Beispiel hatten wir im <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a> kennengelernt.
In diesem Fall durchläuft das Programm eine Endlosschleife, um bei Bedarf auf äußere
Ereignisse adäquat zu reagieren. Aber auch in diesem Fall ist darauf zu achten,
dass es eine Möglichkeit gibt, das Programm kontrolliert, beispielsweise durch
Drücken der Taste <code class="docutils literal notranslate"><span class="pre">q</span></code>, zu beenden. Im Python-Code verwendet man dann den
<code class="docutils literal notranslate"><span class="pre">break</span></code>-Befehl, um die Ausführung des Programmcodes außerhalb der
Schleife fortzusetzen.</p>
</div>
<div class="section" id="verzweigungen">
<span id="ifelse"></span><h2><span class="section-number">4.3. </span>Verzweigungen<a class="headerlink" href="#verzweigungen" title="Link zu dieser Überschrift">¶</a></h2>
<p>Eine andere Art von Kontrollstruktur, die nicht die Wiederholung von Programmcode
regelt, sondern vielmehr auf der Basis einer gegebenen Bedingung entscheidet,
welcher Code ausgeführt wird, sind Verzweigungen.</p>
<p>Im einfachsten Fall wird zusätzlicher Code ausgeführt, wenn eine Bedingung erfüllt
ist. Diese Kontrollstruktur basiert auf der <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung. Zur Illustration greifen
wir auf die näherungsweise Berechnung der Kreiszahl zurück, die wir im <a class="reference internal" href="#forloop"><span class="std std-numref">Kapitel 4.1</span></a>
betrachtet hatten. Insbesondere wenn die Rechnung insgesamt länger dauert, möchte man
vielleicht die Konvergenz der Summation bereits während des Programmlaufs beurteilen.
So können wir uns zum Beispiel jeweils das Zwischenergebnis nach zehntausend Iterationen
ausgeben lassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">nmax</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">summe</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmax</span><span class="p">):</span>
    <span class="n">summe</span> <span class="o">=</span> <span class="n">summe</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">10</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">summe</span><span class="si">:</span><span class="s2">18.16f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">summe</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>         0  1.0000000000000000
     10000  1.6448340818460654
     20000  1.6448840705979586
     30000  1.6449007351814806
     40000  1.6449090677856950
     50000  1.6449140674482257
     60000  1.6449174005982372
     70000  1.6449197814400827
     80000  1.6449215670826174
     90000  1.6449229559223180
3.141583104326456
</pre></div>
</div>
</div>
</div>
<p>Hier wird in der <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung überprüft, ob der Schleifenzähler ohne Rest durch Zehntausend
teilbar ist. Dann ist der Wahrheitswert des logischen Ausdrucks gleich <code class="docutils literal notranslate"><span class="pre">True</span></code> und der folgende
Code-Block wird ausgeführt. Andernfalls wird dieser Block einfach übersprungen. Wie wir es
schon von den <code class="docutils literal notranslate"><span class="pre">for</span></code>- und <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleifen kennen, ist der Code-Block, der zur <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung
gehört, durch die Einrückung kenntlich gemacht. Die <code class="docutils literal notranslate"><span class="pre">print</span></code>-Anweisung in der letzten Zeile ist
nicht mehr eingerückt und gehört damit weder zur <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung noch zur <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife. Sie
wir also erst am Ende des Programmlaufs genau einmal ausgeführt.</p>
<p>Besteht der Code-Block einer <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung nur aus einer einzigen Zeile, so kann man den gesamten
Code in einer einzigen Zeile schreiben. Dies ist allerdings nur sinnvoll, wenn die Anweisung im
Code-Block relativ kurz ist. Statt</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span> <span class="si">= }</span><span class="s1"> ist bestimmt nicht negativ.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x = 4 ist bestimmt nicht negativ.
</pre></div>
</div>
</div>
</div>
<p>kann man also auch</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span> <span class="si">= }</span><span class="s1"> ist bestimmt nicht negativ.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x = 4 ist bestimmt nicht negativ.
</pre></div>
</div>
</div>
</div>
<p>schreiben. Meistens wird aber die erste Variante übersichtlicher sein.</p>
<p>Bei komplizierteren logischen Ausdrücken kann es auch sinnvoll sein, einen Variablennamen
einzuführen, um die Bedeutung des Ausdrucks zu verdeutlichen. Wir illustrieren das anhand
eines kleinen Programms, das eine Liste von Schaltjahren ausgibt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nyear</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1860</span><span class="p">,</span> <span class="mi">2210</span><span class="p">):</span>
    <span class="n">is_leapyear</span> <span class="o">=</span> <span class="p">((</span><span class="n">year</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">100</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_leapyear</span><span class="p">:</span>
        <span class="n">nyear</span> <span class="o">=</span> <span class="n">nyear</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nyear</span> <span class="o">%</span> <span class="mi">12</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1860 1864 1868 1872 1876 1880 1884 1888 1892 1896 1904 1908
1912 1916 1920 1924 1928 1932 1936 1940 1944 1948 1952 1956
1960 1964 1968 1972 1976 1980 1984 1988 1992 1996 2000 2004
2008 2012 2016 2020 2024 2028 2032 2036 2040 2044 2048 2052
2056 2060 2064 2068 2072 2076 2080 2084 2088 2092 2096 2104
2108 2112 2116 2120 2124 2128 2132 2136 2140 2144 2148 2152
2156 2160 2164 2168 2172 2176 2180 2184 2188 2192 2196 2204
2208 
</pre></div>
</div>
</div>
</div>
<p>In der dritten Zeile wird der logische Ausdruck, der auswertet, ob es sich beidem vorgegebenen
Jahr um ein Schaltjahr handelt, der Variable <code class="docutils literal notranslate"><span class="pre">is_leapyear</span></code> zugewiesen. Nur wenn diese Variable
den Wert <code class="docutils literal notranslate"><span class="pre">True</span></code> besitzt, wird das Jahr ausgegeben. Alternativ hätte man natürlich auch eine
Funktion definieren können.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_leapyear</span><span class="p">(</span><span class="n">year</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">year</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">100</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">nyear</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1860</span><span class="p">,</span> <span class="mi">2210</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_leapyear</span><span class="p">(</span><span class="n">year</span><span class="p">):</span>
        <span class="n">nyear</span> <span class="o">=</span> <span class="n">nyear</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nyear</span> <span class="o">%</span> <span class="mi">12</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1860 1864 1868 1872 1876 1880 1884 1888 1892 1896 1904 1908
1912 1916 1920 1924 1928 1932 1936 1940 1944 1948 1952 1956
1960 1964 1968 1972 1976 1980 1984 1988 1992 1996 2000 2004
2008 2012 2016 2020 2024 2028 2032 2036 2040 2044 2048 2052
2056 2060 2064 2068 2072 2076 2080 2084 2088 2092 2096 2104
2108 2112 2116 2120 2124 2128 2132 2136 2140 2144 2148 2152
2156 2160 2164 2168 2172 2176 2180 2184 2188 2192 2196 2204
2208 
</pre></div>
</div>
</div>
</div>
<p>Die letzten vier Zeilen dieser beiden Codebeispiele illustrieren zugleich eine Erweiterung der
<code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung, in der auch eine Alternative im <code class="docutils literal notranslate"><span class="pre">else</span></code>-Zweig vorgesehen ist. Falls <code class="docutils literal notranslate"><span class="pre">nyear</span> <span class="pre">%</span> <span class="pre">12</span></code>
den Wahrheitswert <code class="docutils literal notranslate"><span class="pre">True</span></code> ergibt, also bei der Division von <code class="docutils literal notranslate"><span class="pre">nyear</span></code> durch 12 ein Rest bleibt, wird
der <code class="docutils literal notranslate"><span class="pre">if</span></code>-Zweig ausgeführt. Nach der Jahreszahl wird dann noch ein Leerzeichen ausgegeben, der
Zeilenumbruch entfällt aber. Im allen anderen Fällen, also wenn <code class="docutils literal notranslate"><span class="pre">nyear</span></code> ohne Rest durch 12 teilbar
ist, wird die Anweisung im <code class="docutils literal notranslate"><span class="pre">else</span></code>-Zweig ausgeführt, so dass nach der Ausgabe der Jahreszahl ein
Zeilenumbruch folgt. Auf diese Weise weren zwölf Jahreszahlen je Zeile ausgegeben.</p>
<p>Wichtig ist, dass die <code class="docutils literal notranslate"><span class="pre">else</span></code>-Anweisung so weit eingerückt ist, wie die
zugehörige <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung.  Wäre sie nur einfach eingerückt, würde sie die
Alternative zur ersten <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung bilden. In diesem Fall würde jedes Jahr
zwischen 1860 und 2209 mit Ausnahme jedes zwölften Schaltjahres ausgegeben
werden. Nach den Schaltjahren würde nur ein Leerzeichen gesetzt werden, aber
auf ein Zeilenumbruch verzichtet werden. Dagegen würde nach jedem Jahr, das
kein Schaltjahr ist, ein Zeilenumbruch vorgenommen werden. Korrektes Einrücken
ist also essentiell dafür, dass der Code wie gewünscht abgearbeitet wird.</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nyear</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1860</span><span class="p">,</span> <span class="mi">2210</span><span class="p">):</span>
    <span class="n">is_leapyear</span> <span class="o">=</span> <span class="p">((</span><span class="n">year</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">100</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_leapyear</span><span class="p">:</span>
        <span class="n">nyear</span> <span class="o">=</span> <span class="n">nyear</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">nyear</span> <span class="o">%</span> <span class="mi">12</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1860 1861
1862
1863
1864 1865
1866
1867
1868 1869
1870
1871
1872 1873
1874
1875
1876 1877
1878
1879
1880 1881
1882
1883
1884 1885
1886
1887
1888 1889
1890
1891
1892 1893
1894
1895
1896 1897
1898
1899
1900
1901
1902
1903
1904 1905
1906
1907
1909
1910
1911
1912 1913
1914
1915
1916 1917
1918
1919
1920 1921
1922
1923
1924 1925
1926
1927
1928 1929
1930
1931
1932 1933
1934
1935
1936 1937
1938
1939
1940 1941
1942
1943
1944 1945
1946
1947
1948 1949
1950
1951
1952 1953
1954
1955
1957
1958
1959
1960 1961
1962
1963
1964 1965
1966
1967
1968 1969
1970
1971
1972 1973
1974
1975
1976 1977
1978
1979
1980 1981
1982
1983
1984 1985
1986
1987
1988 1989
1990
1991
1992 1993
1994
1995
1996 1997
1998
1999
2000 2001
2002
2003
2005
2006
2007
2008 2009
2010
2011
2012 2013
2014
2015
2016 2017
2018
2019
2020 2021
2022
2023
2024 2025
2026
2027
2028 2029
2030
2031
2032 2033
2034
2035
2036 2037
2038
2039
2040 2041
2042
2043
2044 2045
2046
2047
2048 2049
2050
2051
2053
2054
2055
2056 2057
2058
2059
2060 2061
2062
2063
2064 2065
2066
2067
2068 2069
2070
2071
2072 2073
2074
2075
2076 2077
2078
2079
2080 2081
2082
2083
2084 2085
2086
2087
2088 2089
2090
2091
2092 2093
2094
2095
2096 2097
2098
2099
2100
2101
2102
2103
2105
2106
2107
2108 2109
2110
2111
2112 2113
2114
2115
2116 2117
2118
2119
2120 2121
2122
2123
2124 2125
2126
2127
2128 2129
2130
2131
2132 2133
2134
2135
2136 2137
2138
2139
2140 2141
2142
2143
2144 2145
2146
2147
2148 2149
2150
2151
2153
2154
2155
2156 2157
2158
2159
2160 2161
2162
2163
2164 2165
2166
2167
2168 2169
2170
2171
2172 2173
2174
2175
2176 2177
2178
2179
2180 2181
2182
2183
2184 2185
2186
2187
2188 2189
2190
2191
2192 2193
2194
2195
2196 2197
2198
2199
2200
2201
2202
2203
2205
2206
2207
2208 2209
</pre></div>
</div>
</div>
</div>
<p>Die <code class="docutils literal notranslate"><span class="pre">if…else</span></code>-Konstruktion lässt in der bisher besprochene Weise zwei mögliche Wege abhängig
davon zu, ob eine Bedingung erfüllt ist oder nicht. Man kann aber auch mehr als zwei Alternativen
vorsehen. Eine erste Möglichkeit, die noch nicht wirklich optimal ist, beruht auf einer Schachtelung
von <code class="docutils literal notranslate"><span class="pre">if…else</span></code>-Verweigungen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist positiv.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist gleich Null.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist negativ.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-2 ist negativ.
-1 ist negativ.
0 ist gleich Null.
1 ist positiv.
2 ist positiv.
</pre></div>
</div>
</div>
</div>
<p>Unter Verwendung der <code class="docutils literal notranslate"><span class="pre">elif</span></code>-Anweisung, die gewissermaßen eine <code class="docutils literal notranslate"><span class="pre">else</span></code>-Anweisung und eine <code class="docutils literal notranslate"><span class="pre">if</span></code>-Anweisung
zusammenzieht, kann man die Verzweigungen etwas weniger hierarchisch hinschreiben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist positiv.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist gleich Null.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist negativ.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-2 ist negativ.
-1 ist negativ.
0 ist gleich Null.
1 ist positiv.
2 ist positiv.
</pre></div>
</div>
</div>
</div>
<p>Hierbei werden nacheinander die Bedingungen <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> und <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code> abgeprüft und für den Fall, dass keiner
der beiden Ausdrücke gleich <code class="docutils literal notranslate"><span class="pre">True</span></code> ist, die letzte Alternative ausgeführt. Wichtig ist dabei, dass die
Verzweigungsstruktur verlassen wird, sobald eine Bedingung erfüllt war und der zugehörige Code ausgeführt
wurde. Dieses Verhalten wird im folgenden Beispiel illustriert.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist positiv.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist gerade.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> ist negativ und nicht gerade.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-2 ist gerade.
-1 ist negativ und nicht gerade.
0 ist gerade.
1 ist positiv.
2 ist positiv.
</pre></div>
</div>
</div>
</div>
<p>Nachdem die <code class="docutils literal notranslate"><span class="pre">2</span></code> als positive Zahl erkannt und entsprechend behandelt wurde, wurde wegen des in <code class="docutils literal notranslate"><span class="pre">elif</span></code>
enthaltenen <code class="docutils literal notranslate"><span class="pre">else</span></code> nicht mehr überprüft, ob die Zahl auch gerade ist.</p>
<p>Im Prinzip kann man mehrere <code class="docutils literal notranslate"><span class="pre">elif</span></code>-Ebenen in einer Verzweigungsstruktur vorsehen. Als erstes muss jedoch
immer eine <code class="docutils literal notranslate"><span class="pre">if</span></code>-Verzweigung stehen. Ein abschließendes <code class="docutils literal notranslate"><span class="pre">else</span></code>, das alle nicht behandelten Fälle abfängt,
kann, muss aber nicht am Ende der Verzweigungsstruktur stehen. Zu bedenken ist allerdings, dass eine lange
Hierarchie von Verzweigungen insbesondere dann nicht günstig ist, wenn erst eine der unteren Bedingung
erfüllt ist, da dann zunächst einmal viele Bedingungen erfolglos ausgewertet werden müssen. In einem solchen
Fall kann zumindest versuchen, dafür zu sorgen, dass die wahrscheinlichsten Fälle weiter oben stehen. In
vielen Fällen kann man aber einen zusammengesetzten Datentyp, das so genannte <code class="docutils literal notranslate"><span class="pre">dictionary</span></code> verwenden, das wir
im <a class="reference internal" href="sequenzen.html#dictionaries"><span class="std std-numref">Kapitel 6.4</span></a> genauer besprechen werden.</p>
</div>
<div class="section" id="abfangen-von-ausnahmen">
<h2><span class="section-number">4.4. </span>Abfangen von Ausnahmen<a class="headerlink" href="#abfangen-von-ausnahmen" title="Link zu dieser Überschrift">¶</a></h2>
<p>In <a class="reference internal" href="datentypen.html#float"><span class="std std-numref">Kapitel 3.2</span></a> hatten wir festgestellt, dass Python auf den Versuch, durch Null zu teilen, mit einer
Ausnahme oder <em>exception</em> reagiert, dem <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>. Unbehandelt führt eine solche Ausnahme zur
Ausgabe einer Fehlermeldung und dem Abbruch der Programmausführung. Man kann solche Ausnahmen aber auch
in geeigneter Weise behandeln. Zur Illustration betrachten wir die Funktion</p>
<div class="math notranslate nohighlight">
\[f(x)=\frac{\sin(x)}{x}\,.\]</div>
<p>Eine numerische Auswertung dieser Funktion an der Stelle <span class="math notranslate nohighlight">\(x=0\)</span> führt zu einer Division durch Null und
damit zu einem <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code> obwohl der Wert der Funktion im Grenzübergang <span class="math notranslate nohighlight">\(x\to 0\)</span> gleich <span class="math notranslate nohighlight">\(1\)</span> ist.</p>
<p>Den speziellen Wert bei <span class="math notranslate nohighlight">\(x=0\)</span> könnte man nun mit Hilfe einer Verzweigung behandeln.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">5.2f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">:</span><span class="s2">8.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.02  0.999933
-0.01  0.999983
 0.00  1.000000
 0.01  0.999983
 0.02  0.999933
</pre></div>
</div>
</div>
</div>
<p>Allerdings muss hier jedes Mal überprüft werden, ob <span class="math notranslate nohighlight">\(x=0\)</span> ist, selbst dann, wenn dies in der Anwendung
vielleicht nur selten oder überhaupt nicht vorkommt. Dennoch wird man den Spezialfall in vielen
Programmiersprachen in dieser Weise behandeln.</p>
<p>In Python folgt man stattdessen meistens dem Motto, dass um Verzeihung zu bitten einfacher ist als um
Erlaubnis zu fragen. Anstatt also immer erst zu überprüfen, ob <span class="math notranslate nohighlight">\(x=0\)</span> ist, dividiert man einfach durch
<span class="math notranslate nohighlight">\(x\)</span> und kümmert sich dann darum, wenn es Probleme gibt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">5.2f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">:</span><span class="s2">8.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.02  0.999933
-0.01  0.999983
 0.00  1.000000
 0.01  0.999983
 0.02  0.999933
</pre></div>
</div>
</div>
</div>
<p>Es wird also zunächst versucht, den Code im <code class="docutils literal notranslate"><span class="pre">try</span></code>-Block auszuführen. Wenn dabei eine
<code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>-Ausnahme auftritt, wird der entsprechende Block ausgeführt.</p>
<p>Es ist zwar im Prinzip nicht erforderlich, im Zusammenhang mit <code class="docutils literal notranslate"><span class="pre">except</span></code> eine oder mehrere Ausnahmen
explizit zu benennen. Es ist aber sinnvoll, in der Nennung der Ausnahmen möglichst restriktiv zu sein,
da sonst Fehler eventuell unentdeckt bleiben können, wie in dem folgenden Beispiel gezeigt ist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;xxx&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">7</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">:</span><span class="s2">8.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  -0.01  0.999983
      0  1.000000
xxx      1.000000
</pre></div>
</div>
</div>
</div>
<p>Übergibt man als Argument hier eine Zeichenkette, so kommt es bei der Division zu einem <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>,
der hier vom <code class="docutils literal notranslate"><span class="pre">except</span></code>-Block mit behandelt wird. Besser wäre es, diesen beispielsweise in einem zweiten
<code class="docutils literal notranslate"><span class="pre">except</span></code>-Block separat und adäquat zu behandeln.</p>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Nach dem <code class="docutils literal notranslate"><span class="pre">try</span></code>- und einem oder mehreren <code class="docutils literal notranslate"><span class="pre">except</span></code>-Blöcken kann noch ein <code class="docutils literal notranslate"><span class="pre">else</span></code>- oder ein <code class="docutils literal notranslate"><span class="pre">finally</span></code>-Block
folgen. Der <code class="docutils literal notranslate"><span class="pre">else</span></code>-Block wird nur dann ausgeführt, wenn keine Ausnahme die Abarbeitung eines <code class="docutils literal notranslate"><span class="pre">except</span></code>-Blocks
erzwingt. Dadurch ist es leicht möglich, den <code class="docutils literal notranslate"><span class="pre">try</span></code>-Block auf den relevanten Codeteil zu begrenzen. Ein
<code class="docutils literal notranslate"><span class="pre">finally</span></code>-Block wird dagegen immer ausgeführt, zum Beispiel um notwendige Aufräumarbeiten auszuführen.</p>
</div>
<p>Abschließend wollen wir noch kurz demonstrieren, wie man Ausnahmen selbst gezielt zur Fehlerbehandlung
einsetzen kann. Dazu greifen wir auf die Funktion <code class="docutils literal notranslate"><span class="pre">get_result</span></code> des Spiels zurück, das wir in <a class="reference internal" href="vorschau.html#vorschau"><span class="std std-numref">Kapitel 2</span></a>
gesprochen hatten. Dabei mussten die beiden Argumente ganze Zahlen zwischen 0 und 2 einschließlich sein.
Für unsere Zwecke nehmen wir an, dass sichergestellt sei, dass die Argumente ganze Zahlen sind. Wir
wollen aber den Fehlerfall von Argumenten außerhalb des vorgegebenen Bereichs behandeln.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>

<span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="n">n_self</span><span class="p">,</span> <span class="n">n_other</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n_self</span> <span class="o">&lt;=</span><span class="mi">2</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n_other</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_self</span> <span class="si">= }</span><span class="s2"> und </span><span class="si">{</span><span class="n">n_other</span> <span class="si">= }</span><span class="s2"> müssen beide zwischen 0 und 2 liegen.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n_self</span><span class="o">-</span><span class="n">n_other</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">n_self</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">n_other</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">get_result</span><span class="p">(</span><span class="n">n_self</span><span class="p">,</span> <span class="n">n_other</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ergebnis für </span><span class="si">{</span><span class="n">n_self</span> <span class="si">= }</span><span class="s2"> und </span><span class="si">{</span><span class="n">n_other</span> <span class="si">= }</span><span class="s2">: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>n_self = 0 und n_other = 3 müssen beide zwischen 0 und 2 liegen.
n_self = 3 und n_other = -1 müssen beide zwischen 0 und 2 liegen.
n_self = 3 und n_other = -1 müssen beide zwischen 0 und 2 liegen.
Ergebnis für n_self = 1 und n_other = 1: 0
n_self = 0 und n_other = -1 müssen beide zwischen 0 und 2 liegen.
</pre></div>
</div>
</div>
</div>
<div class="admonition-hinweis admonition">
<p class="admonition-title">Hinweis</p>
<p>In diesem Codebeispiel wird in der <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife ein Unterstrich als Variablenname verwendet. Von dieser Möglichkeit
sollte man nur sparsamen Gebrauch machen, da ein Unterstrich im Allgemeinen nicht sehr aussagekräftig ist. Im
vorliegenden Fall deutet der Unterstrich an, dass die Laufvariable in der Schleife nicht weiter verwendet
wird.</p>
</div>
<p>In der Funktion <code class="docutils literal notranslate"><span class="pre">get_result</span></code> wird mit Hilfe der <code class="docutils literal notranslate"><span class="pre">raise</span></code>-Anweisung im Fehlerfall
eine <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>-Ausnahme ausgelöst, die zudem eine informative Fehlermeldung
enthält. Im aufrufenden Programm wird mit einer <code class="docutils literal notranslate"><span class="pre">try…except</span></code>-Konstruktion der
<code class="docutils literal notranslate"><span class="pre">ValueError</span></code> abgefangen und die in der hier <code class="docutils literal notranslate"><span class="pre">e</span></code> genannten Variable enthaltene
Fehlermeldung ausgegeben.</p>
<p>Einen Überblick über die von Python vordefinierten Ausnahmen findet man in der <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">Dokumentation der
Python-Standardbibliothek</a>.
Darüber hinaus ist es auch möglich, eigene Ausnahmen zu definieren.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="datentypen.html" title="previous page"><span class="section-number">3. </span>Einfache Datentypen, Variablen und Zuweisungen</a>
    <a class='right-next' id="next-link" href="funktionen.html" title="next page"><span class="section-number">5. </span>Funktionen</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Gert-Ludwig Ingold<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>