
<!DOCTYPE html>

<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>6. Zusammengesetzte Datentypen &#8212; Einführung in Prinzipien der Programmierung</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="genindex.html" />
    <link rel="search" title="Suche" href="search.html" />
    <link rel="next" title="7. Ein- und Ausgabe" href="einausgabe.html" />
    <link rel="prev" title="5. Funktionen" href="funktionen.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="de">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Einführung in Prinzipien der Programmierung</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="einleitung.html">
   1. Einleitung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="vorschau.html">
   2. Eine Vorschau
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="datentypen.html">
   3. Einfache Datentypen, Variablen und Zuweisungen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kontrollstrukturen.html">
   4. Kontrollstrukturen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="funktionen.html">
   5. Funktionen
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   6. Zusammengesetzte Datentypen
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="einausgabe.html">
   7. Ein- und Ausgabe
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="scipy.html">
   8. Numerische Programmbibliotheken am Beispiel von NumPy/SciPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="objektorientiert.html">
   9. Objektorientiertes Programmieren
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zahlensysteme.html">
   10. Anhang: Zahlensysteme
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="floats.html">
   11. Anhang: 64-Bit-Gleitkommazahlen nach IEEE-Standard 754
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="unicode.html">
   12. Anhang: Unicode
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/gertingold/epriprog/master?urlpath=tree/epriprog/sequenzen.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/sequenzen.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download notebook file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-code"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        <a href="_sources/sequenzen.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#listen">
   6.1. Listen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tupel">
   6.2. Tupel
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#zeichenketten">
   6.3. Zeichenketten
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dictionaries">
   6.4. Dictionaries
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Zusammengesetzte Datentypen</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#listen">
   6.1. Listen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tupel">
   6.2. Tupel
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#zeichenketten">
   6.3. Zeichenketten
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dictionaries">
   6.4. Dictionaries
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="zusammengesetzte-datentypen">
<span id="zusgdatentypen"></span><h1><span class="section-number">6. </span>Zusammengesetzte Datentypen<a class="headerlink" href="#zusammengesetzte-datentypen" title="Link zu dieser Überschrift">#</a></h1>
<section id="listen">
<span id="id1"></span><h2><span class="section-number">6.1. </span>Listen<a class="headerlink" href="#listen" title="Link zu dieser Überschrift">#</a></h2>
<p>Bei der Lösung numerischer Probleme spielen die Zahlentypen, die wir im <a class="reference internal" href="datentypen.html#datentypen"><span class="std std-numref">Kapitel 3</span></a>
kennengelernt haben, also Integers, Gleitkommazahlen oder Floats sowie komplexe Zahlen eine
zentrale Rolle. Insbesondere in den Natur- und Ingenieurwissenschaften sind diese Daten aber
Bestandteile von komplexeren Datentypen wie Vektoren oder Matrizen. Man spricht in diesem
Zusammenhang von zusammengesetzten Datentypen, die wir im Folgenden behandeln wollen. Dabei
müssen die Bestandteile nicht unbedingt numerischer Natur sein. Ein Beispiel hierfür wären
Zeichenketten.</p>
<p>Bei den zusammengesetzten Datentypen ist es sinnvoll, eine Unterscheidung vorzunehmen, die
die Art der einzelnen Bestandteile betrifft. In Programmiersprachen wie Fortran oder C
kennt man den Datentyp des Arrays, das eine ein- oder mehrdimensionale Ansammlung von
Zahlen des gleichen Datentyps umfasst. Jedes Element nimmt im Speicher gleich viel Platz
in Anspruch und die aufeinanderfolgende Elemente schließen im Speicher nahtlos aneinander
an. Da die Anordnung der Elemente im Speicher immer eindimensional ist, gibt es für die
Speicherung mehrdimensionaler Array unterschiedliche Zugänge und tatsächlich unterscheiden
sich Fortran und C in dieser Hinsicht. Die homogene Struktur von Arrays hat zur Folge,
dass der Ort eines durch einen Index oder auch mehrere Indizes adressierten Elements im
Speicher ausgehend von der Startadresse unmittelbar berechnet werden kann. Dadurch kann
man sehr effizient auf Elemente des Arrays zugreifen.</p>
<p>In Python dagegen stehen solche homogenen Datenansammlungen in Form von Arrays nicht im
Standardsprachumfang zur Verfügung. Sie werden aber durch die Programmbibliothek NumPy,
die die Basis für wissenschaftliche Numerik in Python bildet und die wir im
<a class="reference internal" href="scipy.html#scipy"><span class="std std-numref">Kapitel 8</span></a> besprechen werden, bereitgestellt. Python stellt stattdessen standardmäßig
den Datentyp einer Liste zur Verfügung, die Objekte verschiedener Datentypen enthalten
kann, aber nicht muss. Die größere Flexibilität der Liste gegenüber den Arrays bezahlt man
mit einem höheren Aufwand beim Zugriff auf einzelne Elemente. Wir werden im Folgenden
Listen als Datentyp in Python besprechen. Viele Aspekte werden wir später auf die von
NumPy zur Verfügung gestellten Arrays übertragen können.</p>
<p>Listen sind uns beispielsweise bereits in <a class="reference internal" href="kontrollstrukturen.html#forloop"><span class="std std-numref">Kapitel 4.1</span></a> begegnet, wo wir die
<code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion verwendet hatten, um einen Schleifenzähler mit Werten zu versorgen.
Dabei werden die benötigten Werte nur bei Bedarf erzeugt. Um alle Werte auf einmal zu
sehen, hatten wir die <code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code>-Funktion verwendet und dabei eine Liste erzeugt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>meine_liste = list(range(20))
print(meine_liste)
print(type(meine_liste))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
&lt;class &#39;list&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Mit der zweiten Ausgabezeile wird hier nachgewiesen, dass der Datentyp des Objekts
<code class="docutils literal notranslate"><span class="pre">meine_liste</span></code> tatsächlich eine Liste ist.</p>
<p>Wenn man die Länge einer Liste nicht kennt, kann man diese mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code>-Funktion
bestimmen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>liste1 = list(range(1, 17, 3))
print(f&#39;Länge der ersten Liste:  {len(liste1)} Elemente&#39;)
liste2 = [&#39;Stein&#39;, &#39;Papier&#39;, &#39;Schere&#39;]
print(f&#39;Länge der zweiten Liste: {len(liste2)} Elemente&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Länge der ersten Liste:  6 Elemente
Länge der zweiten Liste: 3 Elemente
</pre></div>
</div>
</div>
</div>
<p>Eine wichtige Eigenschaft von Listen besteht darin, dass man einzelne Listenelement oder auch
Ausschnitte aus der Liste adressieren kann und diese auch verändern kann. Wir demonstrieren
dies zunächst an einem einzelnen Listenelement.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>meine_liste = [1, 17, 3]
print(meine_liste[1])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>17
</pre></div>
</div>
</div>
</div>
<p>Zu beachten ist hier, dass der Index immer in eckigen Klammern stehen muss.</p>
<p>Das Ergebnis zeigt, dass die Zählung in Python bei 0 beginnt, wie es beispielsweise auch in
der Programmiersprache C der Fall ist. Diese Wahl lässt sich dadurch motivieren, dass die Position
des ersten Elements einer Liste relativ zum Beginn der Liste im Speicherplatz durch einen Offset
von 0 gegeben ist. Man könnte aber auch argumentieren, dass das erste Element durch den Index 1
adressiert werden sollte. Diese Wahl wurde in der Programmiersprache Fortran getroffen. Man muss
sich also diesbezüglich informieren, welche Konvention in der verwendeten Programmiersprache gilt.</p>
<p>Eine Veränderung eines Listenelements ist durch eine Zuweisung für das betreffende Listenelement
möglich.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>meine_liste[1] = 2
print(meine_liste)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
</pre></div>
</div>
</div>
</div>
<p>Neben der Möglichkeit, einzelne Listenelemente anzusprechen, ist es auch möglich, mehrere Listenelemente
auf einmal zu adressieren. Dabei kann es sich entweder um eine gegebene Anzahl direkt aufeinanderfolgender
Listenelemente oder mehrere Listenelemente mit einem festen Abstand handeln. In der folgenden
Liste von Primzahlen werden alle Elemente ab Index 1, also ab dem zweiten Element, bis ausschließlich
dem Index 5 ausgewählt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>primzahlen = [2, 3, 5, 7, 11, 13, 17, 19, 23]
print(primzahlen[1:5])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[3, 5, 7, 11]
</pre></div>
</div>
</div>
</div>
<p>Gerade zu Beginn ist es oft ungewohnt, dass das Element zum zweiten Index nicht Teil der Auswahl ist,
auch wenn wir dies von der <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion schon gewohnt sind. Man kann sich dieses Verhalten
dadurch veranschaulichen, dass man sich den Index nicht als Nummerierung eines Elements vorstellt, sondern
als Markierung »zwischen« den Listeneinträgen, wie es in <a class="reference internal" href="#fig-slices"><span class="std std-numref">Abb. 6.1</span></a> gezeigt ist.</p>
<figure class="align-default" id="fig-slices">
<a class="reference internal image-reference" href="_images/listnumbering1.png"><img alt="_images/listnumbering1.png" src="_images/listnumbering1.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 6.1 </span><span class="caption-text">Die Indizierung von Listen lässt sich besser verstehen, wenn man den Index als Markierung »zwischen« den
Listeneinträgen versteht.</span><a class="headerlink" href="#fig-slices" title="Link zu diesem Bild">#</a></p>
</figcaption>
</figure>
<p>Da man in diesem Bild die Liste praktisch wie einen Brotlaib in Scheiben schneidet,
spricht man bei der Adressierung von <em>slices</em>. Wie <a class="reference internal" href="#fig-slices"><span class="std std-numref">Abb. 6.1</span></a> mit den <em>slices</em>
<code class="docutils literal notranslate"><span class="pre">[0:5]</span></code> und <code class="docutils literal notranslate"><span class="pre">[5:8]</span></code> zeigt, ist die von Python benutzte Indizierungskonvention auch
insofern praktisch als aufeinanderfolgende <em>slices</em> den gleichen End -bzw. Anfangsindex
haben.</p>
<p>Wie bei der <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code>-Funktion gibt es auch bei den <em>slices</em> die Möglichkeit, die
Schrittweite zu wählen. Die Bedeutung der Argumente ist in beiden Fällen gleich, nur dass
in der <em>slice</em>-Notation die Argumente jeweils durch einen Doppelpunkt getrennt sind.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[1:8:2])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[3, 7, 13, 19]
</pre></div>
</div>
</div>
</div>
<p>Hierbei wird aus der obigen Primzahlliste ausgehend vom zweiten Eintrag bis zum achten
Eintrag jedes zweite Element ausgewählt.</p>
<p>Wie würde man vorgehen, wenn man ausgehend vom ersten Element jedes dritte Element der
Primzahlliste ausgeben möchte. Für die vollständige Indexangabe wird man zunächst einmal
die Länge der Liste bestimmen müssen, wenn man diese nicht schon kennt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[0:len(primzahlen):3])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 7, 17]
</pre></div>
</div>
</div>
</div>
<p>Alternativ kann man aber das Ende der Liste dadurch spezifizieren, dass man den
entsprechenden Eintrag leer lässt. Das Fehlen des Index ist dabei anhand der Doppelpunkte
erkenntlich.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[0::3])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 7, 17]
</pre></div>
</div>
</div>
</div>
<p>Entsprechend könnten man den ersten Index weglassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[::3])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 7, 17]
</pre></div>
</div>
</div>
</div>
<p>Lässt man auch den dritten Index weg, so wird die Schrittweite automatisch auf 1 gesetzt.
Statt zwei Doppelpunkten ist es dann aber einfacher, nur einen Doppelpunkt zu setzen. Auf
diese Weise erhält man alle Elemente der Liste. Es ist allerdings nicht möglich, alle
Doppelpunkte wegzulassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[::])
print(primzahlen[:])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 3, 5, 7, 11, 13, 17, 19, 23]
[2, 3, 5, 7, 11, 13, 17, 19, 23]
</pre></div>
</div>
</div>
</div>
<p>Alle Listenelemente kann man zwar auch einfach durch die Angabe des Listennamens ausgeben.
Allerdings werden wir später noch sehen, dass es einen Unterschied macht, ob man nur den
Listennamen verwendet oder ein <em>slice</em> <code class="docutils literal notranslate"><span class="pre">[:]</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 3, 5, 7, 11, 13, 17, 19, 23]
</pre></div>
</div>
</div>
</div>
<p>Insbesondere wenn die Indizes in einem <em>slice</em> durch Programmcode erzeugt werden, kann es
passieren, dass ein Index irrtümlich außerhalb des erlaubten Bereichs liegt. In einer solchen
Situation können verschiedene Dinge passieren. Manche Programmiersprachen berechnen, zumindest
unter bestimmten Bedingungen, einfach den entsprechenden Ort im Speicher und verwenden die dort
vorhandenen Daten, sofern das Programm auf diesen Speicherbereich Zugriffsrechte besitzt. Solche
Situationen führen zu Fehlern, die unter Umständen schwer zu identifizieren sind, unter anderem
weil das Verhalten in solchen Situationen nicht reproduzierbar sein muss. Normalerweise kann
man die betreffenden Programmiersprachen aber dazu zwingen, die Gültigkeit des angegebenen Index
zu überprüfen.</p>
<p>Python macht dies immer und so führt ein Zugriff jenseits der oberen Grenze der Liste zu einer
Exception.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[20])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">IndexError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="nb">print</span><span class="p">(</span><span class="n">primzahlen</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span>

<span class="ne">IndexError</span>: list index out of range
</pre></div>
</div>
</div>
</div>
<p>Dagegen sind negative Indizes in einem gewissen Rahmen erlaubt, nämlich von <code class="docutils literal notranslate"><span class="pre">-1</span></code> bis <code class="docutils literal notranslate"><span class="pre">-N</span></code>,
wobei <code class="docutils literal notranslate"><span class="pre">N</span></code> die Zahl der Listenelemente ist. Die Zuordnung der Listenindizes ist in
<a class="reference internal" href="#fig-negativeindices"><span class="std std-numref">Abb. 6.2</span></a> dargestellt. Mit negativen Indizes ist es also möglich,
Listenelemente vom Ende her zu adressieren ohne die Länge der Liste kennen zu müssen.</p>
<figure class="align-default" id="fig-negativeindices">
<a class="reference internal image-reference" href="_images/listnumbering2.png"><img alt="_images/listnumbering2.png" src="_images/listnumbering2.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Abb. 6.2 </span><span class="caption-text">Mit negativen Indizes lassen sich Listenelemente vom Ende der Liste her adressieren.</span><a class="headerlink" href="#fig-negativeindices" title="Link zu diesem Bild">#</a></p>
</figcaption>
</figure>
<p>So lässt sich beispielsweise sehr leicht das letzte Element einer Liste extrahieren.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen)
print(primzahlen[-1])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 3, 5, 7, 11, 13, 17, 19, 23]
23
</pre></div>
</div>
</div>
</div>
<p>Auch die letzten drei Elemente lassen sich auf entsprechende Weise leicht erhalten.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[-3:])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[17, 19, 23]
</pre></div>
</div>
</div>
</div>
<p>Mit einer negativen Schrittweite kann man die Listen in umgekehrter Reihenfolge anordnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(primzahlen[::-1])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[23, 19, 17, 13, 11, 7, 5, 3, 2]
</pre></div>
</div>
</div>
</div>
<p>Bei der Arbeit mit Listen in Python ist zu beachten, dass sich diese nicht immer so
verhalten, wie man es vielleicht erwarten würde. So erzeugt die Zuweisung einer Liste zu
einer anderen Liste nicht zu einer unabhängigen Liste, sondern nur zu einem zweiten Namen,
unter dem die ursprüngliche Liste angesprochen werden kann. Man spricht hier auch von
einem <em>Alias</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 17, 3]
b = a
a[1] = 2
print(a)
print(b)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
[1, 2, 3]
</pre></div>
</div>
</div>
</div>
<p>Offenbar wurde hier nicht nur die Liste <code class="docutils literal notranslate"><span class="pre">a</span></code> verändert. Tatsächlich zeigen die beiden Namen
<code class="docutils literal notranslate"><span class="pre">a</span></code> und <code class="docutils literal notranslate"><span class="pre">b</span></code> auf das gleiche Pythonobjekt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(id(a), id(b))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>139969708604672 139969708604672
</pre></div>
</div>
</div>
</div>
<p>Anders sieht es aus, wenn man die Listenelemente zuweist.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 17, 3]
b = a[:]
a[1] = 2
print(a)
print(b)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
[1, 17, 3]
</pre></div>
</div>
</div>
</div>
<p>Nun handelt es sich bei den beiden Listen in der Tat auch um verschiedene Pythonobjekte.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(id(a), id(b))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>139969708553856 139969708630464
</pre></div>
</div>
</div>
</div>
<p>Dieses Verhalten wirkt sich auch aus, wenn man Listen an Funktionen übergibt und innerhalb
der Funktion verändert.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def modify_list(x):
    x[0] = 2

meine_liste = [1, 2, 3]
modify_list(meine_liste)
print(meine_liste)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[2, 2, 3]
</pre></div>
</div>
</div>
</div>
<p>Die vorgenommene Änderung ist also nicht lokal auf die Funktion beschränkt, sondern wirkt
sich auf die Liste im Hauptteil aus. Daher sollte man bei der Übergabe von Listen an
Funktionen besondere Sorgfalt walten lassen und diese in der Funktion entweder nicht
verändern oder zunächst eine Kopie anfertigen.</p>
<p>Wie wir eingangs dieses Kapitels schon besprochen hatten, lassen Listen in Python im
Gegensatz zu den homogenen Arrays anderer Programmiersprachen auch unterschiedliche
Datentypen als Elemente einer Liste zu. Dies wollen wir an einer Liste demonstrieren, die
eine mathematische Aufgabe in einer Liste spezifiziert, indem das erste Element ein
Funktionsobjekt enthält während das zweite Element das zugehörige Argument enthält.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from math import sin, pi
aufgabe = [sin, pi/6]
ergebnis = aufgabe[0](aufgabe[1])
print(ergebnis)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.49999999999999994
</pre></div>
</div>
</div>
</div>
<p>Dabei ist die Abweichung vom erwarteten Ergebnis <code class="docutils literal notranslate"><span class="pre">0.5</span></code> durch Rundungsfehler bedingt.</p>
<p>Es ist auch möglich, Listen als Listenelemente zu verwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [[1, 2], [3, 4]]
print(a[0])
print(a[1])
print(a[0][1])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2]
[3, 4]
2
</pre></div>
</div>
</div>
</div>
<p>Hier wird beispielsweise mit <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> das erste Element der Liste <code class="docutils literal notranslate"><span class="pre">a</span></code> adressiert, also die
Liste <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code>. Aus dieser Liste kann wiederum ein Element ausgewählt werden, zum Beispiel
<code class="docutils literal notranslate"><span class="pre">a[0][1]</span></code>.</p>
<p>Auch wenn diese Liste von Listen den Anschein erwecken mag, als Matrix verwendet werden zu
können, ist dies nicht wirklich der Fall. Zum einen ist es zwar leicht möglich, einen
Zeilenvektor aus der Matrix zu extrahieren, wie wir an unserem Beispiel gesehen haben.
Es ist aber nicht möglich, in entsprechender Weise einen Spaltenvektor zu erhalten. Zudem
sind keine Matrixoperationen wie zum Beispiel eine Matrixmultiplikation für Listen von
Listen definiert. Stattdessen verwendet man für diese Zwecke die Numpy-Arrays, die wir in
<a class="reference internal" href="scipy.html#scipy"><span class="std std-numref">Kapitel 8</span></a> besprechen werden.</p>
<p>Andererseits können Listen in <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleifen nützlich sein. So kann man über die
einzelnen Listenelemente der Matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> iterieren.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for liste in a:
    print(liste)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2]
[3, 4]
</pre></div>
</div>
</div>
</div>
<p>Häufig ist es in solchen Fälle sinnvoll, die einzelnen Listenelemente gleich zu entpacken.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for x, y in a:
    print(f&quot;{x} * {y} = {x*y}&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 * 2 = 2
3 * 4 = 12
</pre></div>
</div>
</div>
</div>
<p>Wie wir bereits gesehen hatten, können wir Listenelemente verändern. Es ist uns allerdings
nicht möglich, auf die gleiche Weise Listenelemente hinzufügen. Das folgende Beispiel kann
nicht funktionieren, da versucht wird, auf ein nicht existierendes Listenelement
zuzugreifen.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 2, 3]
a[3] = 4
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">IndexError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span> <span class="n">line</span> <span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>

<span class="ne">IndexError</span>: list assignment index out of range
</pre></div>
</div>
</div>
</div>
<p>Es ist jedoch möglich, mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code>-Methode Elemente an eine Liste
anzuhängen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 2, 3]
a.append(4)
print(a)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3, 4]
</pre></div>
</div>
</div>
</div>
<p>Zu beachten ist hier, dass die Liste verändert wird ohne dass eine Zuweisung notwendig
wäre. Würde man das Ergebnis der <code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code>-Methode der Variable <code class="docutils literal notranslate"><span class="pre">a</span></code> zuweisen, so
würde die Liste mit dem Wert <code class="docutils literal notranslate"><span class="pre">None</span></code> überschrieben werden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 2, 3]
a = a.append(4)
print(a)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None
</pre></div>
</div>
</div>
</div>
<p>Häufig werden im Rahmen einer Schleife mehrere Listenelemente zu einer Liste hinzugefügt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = []
for n in range(10):
    a.append(n**2)
print(a)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</pre></div>
</div>
</div>
</div>
<p>In einfacheren Fällen kann eine sogenannte <em>list comprehension</em> eine kompaktere Lösung
darstellen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [n**2 for n in range(10)]
print(a)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</pre></div>
</div>
</div>
</div>
<p>In einer <em>list comprehension</em> lassen sich auch noch Bedingungen stellen, aber man sollte
sich davor hüten, solche Konstruktionen zu komplex werden zu lassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [n**2 for n in range(10) if n % 3]
print(a)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 4, 16, 25, 49, 64]
</pre></div>
</div>
</div>
</div>
<p>Die <code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code>-Methode muss von der <code class="xref py py-func docutils literal notranslate"><span class="pre">extend()</span></code>-Methode unterschieden werden,
mit der eine Liste an eine andere Liste angehängt werden kann. Mit der <code class="docutils literal notranslate"><span class="pre">append</span></code>-Methode
würde die Liste dagegen ein Element der ersten Liste werden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 2]
b = [3, 4]
a.extend(b)
print(a)
a = [1, 2]
a.append(b)
print(a)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3, 4]
[1, 2, [3, 4]]
</pre></div>
</div>
</div>
</div>
<p>Das Verketten von zwei Listen ist auch mit einem Additionsoperator <code class="docutils literal notranslate"><span class="pre">+</span></code> möglich. Dagegen
ist es nicht möglich, auf diese Weise ein einzelnes Listenelement hinzuzufügen.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 2]
b = [3, 4]
print(a + b)
print(a + 4)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 3, 4]
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">line</span> <span class="mi">4</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">4</span> <span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>

<span class="ne">TypeError</span>: can only concatenate list (not &quot;int&quot;) to list
</pre></div>
</div>
</div>
</div>
<p>Neben der Addition von Listen ist auch die Multiplikation einer Liste mit einer nichtnegativen
ganzen Zahl möglich.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = [1, 2]
print(a*5)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(a*0)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>b = [0]
print(b*10)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre></div>
</div>
</div>
</div>
<p>Neben <code class="docutils literal notranslate"><span class="pre">append</span></code> und <code class="docutils literal notranslate"><span class="pre">extend</span></code> gibt es noch weitere Methoden, um mit Listen zu arbeiten. Wir
wollen hier nur ein paar Beispiele aufführen und verweisen ansonsten auf die
<a class="reference external" href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">Python-Dokumentation</a>.</p>
<p>Bei der Suche nach einem bestimmten Wert in einer Liste kann die <code class="xref py py-func docutils literal notranslate"><span class="pre">index()</span></code>-Methode hilfreich
sein, die den Index des Elements angibt, in dem der gesuchte Wert zum ersten Mal auftritt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>meine_liste = [1, 2, 3, 4, 3, 2, 1]
idx1 = meine_liste.index(2)
print(f&quot;Index: {idx1}  Wert: {meine_liste[idx1]}&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Index: 1  Wert: 2
</pre></div>
</div>
</div>
</div>
<p>Möchte man die Suche fortsetzen, so muss man darauf achten, sich auf den Teil der Liste nach dem
bereits gefundenen Listenelement zu beschränken.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>offset = idx1+1
idx2 = meine_liste[offset:].index(2)
print(f&quot;Index: {offset+idx2}  Wert: {meine_liste[offset+idx2]}&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Index: 5  Wert: 2
</pre></div>
</div>
</div>
</div>
<p>Kommt das gesuchte Element nicht in der Liste vor, so erhält man einen <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>meine_liste.index(5)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ValueError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">38</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">meine_liste</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="ne">ValueError</span>: 5 is not in list
</pre></div>
</div>
</div>
</div>
<p>Um solche Fälle vernünftig zu behandeln, sollte man die Ausnahme abfangen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for n in range(7):
    try:
        print(f&quot;Erstes Auftreten von {n}: {meine_liste.index(n)}&quot;)
    except ValueError:
        print(f&quot;{n} wurde nicht gefunden.&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 wurde nicht gefunden.
Erstes Auftreten von 1: 0
Erstes Auftreten von 2: 1
Erstes Auftreten von 3: 2
Erstes Auftreten von 4: 3
5 wurde nicht gefunden.
6 wurde nicht gefunden.
</pre></div>
</div>
</div>
</div>
<p>Ist man ausschließlich daran interessiert, ob ein Wert in der Liste vorhanden ist, aber
nicht daran, wo sich dieser Wert befindet, so kann man den <code class="docutils literal notranslate"><span class="pre">in</span></code>-Operator verwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for n in range(7):
    if n in meine_liste:
        print(f&quot;{n} ist vorhanden&quot;)
    else:
        print(f&quot;{n} ist nicht vorhanden&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 ist nicht vorhanden
1 ist vorhanden
2 ist vorhanden
3 ist vorhanden
4 ist vorhanden
5 ist nicht vorhanden
6 ist nicht vorhanden
</pre></div>
</div>
</div>
</div>
<p>Benötigt man jedoch auch die Position des Eintrags, so sollte man direkt die vorige
Variante wählen.</p>
<p>Abschließend sei noch erwähnt, dass man Listen mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">sort()</span></code>-Methode
sortieren kann. Auch dies geschieht <em>in place</em>, es wird also keine neue Liste erzeugt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from random import randint
zufallsliste = [randint(1, 100) for _ in range(20)]
print(zufallsliste)
zufallsliste.sort()
print(zufallsliste)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[21, 96, 65, 43, 11, 95, 99, 30, 64, 96, 30, 60, 61, 37, 49, 30, 1, 69, 63, 99]
[1, 11, 21, 30, 30, 30, 37, 43, 49, 60, 61, 63, 64, 65, 69, 95, 96, 96, 99, 99]
</pre></div>
</div>
</div>
</div>
<p>Bei Bedarf ist es auch möglich, einen Sortierschlüssel anzugeben. Möchte man zum Beispiel
nach der letzten Ziffer sortieren, so kann man diese mit einer geeigneten Lambda-Funktion
bewerkstelligen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>zufallsliste = [randint(1, 100) for _ in range(20)]
print(zufallsliste)
zufallsliste.sort(key=lambda x: x % 10)
print(zufallsliste)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[98, 82, 7, 91, 30, 23, 35, 22, 60, 31, 93, 26, 14, 54, 18, 47, 60, 69, 94, 3]
[30, 60, 60, 91, 31, 82, 22, 23, 93, 3, 14, 54, 94, 35, 26, 7, 47, 98, 18, 69]
</pre></div>
</div>
</div>
</div>
</section>
<section id="tupel">
<span id="id2"></span><h2><span class="section-number">6.2. </span>Tupel<a class="headerlink" href="#tupel" title="Link zu dieser Überschrift">#</a></h2>
<p>Tupel sind Listen insofern ähnlich als sie als Elemente Objekte beliebigen Typs enthalten
können.  Andererseits sind sie nicht veränderlich. Man sagt auch, dass Listen veränderlich
(<em>mutable</em>) seien, während Tupel unveränderlich (<em>immutable</em>) sind. Dies bedeutet, dass
man auf Elemente von Tupeln mit <em>slices</em> wie bei Listen zugreifen kann. Es ist jedoch
nicht möglich, diese Elemente zu verändern, und es existiert beispielsweise auch keine
<code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code>-Methode, mit der man Elemente an ein Tupel anhängen könnte. Man kann zwar
Tupel mit Hilfe des Additionsoperators aneinanderhängen, was von der Funktionalität an die
<code class="xref py py-func docutils literal notranslate"><span class="pre">extend()</span></code>-Methode von Listen erinnert.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>mytuple1 = (1, 2)
mytuple2 = (3, 4)
print(f&#39;{id(mytuple1) = }&#39;)
print(f&#39;{id(mytuple2) = }&#39;)

mytuple1 = mytuple1 + mytuple2
print(f&#39;{mytuple1 = }&#39;)
print(f&#39;{id(mytuple1) = }&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id(mytuple1) = 139969707646208
id(mytuple2) = 139969708104512
mytuple1 = (1, 2, 3, 4)
id(mytuple1) = 139969708050928
</pre></div>
</div>
</div>
</div>
<p>Offensichtlich wird hier ein neues Tupel erzeugt, genauso wie die Verknüpfung zweier
Listen mit Hilfe des Additionsoperators eine neue Liste erzeugen würde. Bei der
<code class="xref py py-func docutils literal notranslate"><span class="pre">extend()</span></code>-Methode für Listen ist dies dagegen nicht der Fall.</p>
<div class="tip admonition">
<p class="admonition-title">Tipp</p>
<p>Das Zusammenfügen von Tupeln mit Hilfe des Additionsoperators ist ineffizient,
insbesondere wenn es oft geschieht. Je nach Problemstellung ist es daher sinnvoll,
zunächst eine Liste zu erstellen oder die benötigten Elemente mit einem Generatorausdruck
zu erzeugen und anschließend mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code>-Funktion ein Tupel zu erzeugen.</p>
</div>
<p>Wozu sind Tupel nützlich, wenn sie im Wesentlichen Listen mit eingeschränkter
Funktionalität sind? Die Unveränderbarkeit von Tupeln kann in der Praxis nützlich sein.
Bei der Besprechung von Listen hatten wir zum Beispiel gesehen, dass besondere Vorsicht bei der
Übergabe von Listen an Funktionen geboten ist, wenn innerhalb der Funktion Listenelemente verändert
werden, da sich diese Änderungen auch außerhalb der Funktion auswirken. Bei Tupeln ist dies nicht der
Fall, so dass sich diese besser für die Übergabe von Daten an eine Funktion eignen. In <a class="reference internal" href="#dictionaries"><span class="std std-numref">Kapitel 6.4</span></a>
werden wir später noch sehen, dass Tupel, im Gegensatz zu Listen, auch als Schlüssel in sogenannten
<em>dictionaries</em> Verwendung finden können. Es gibt also gute Gründe, warum es neben den veränderlichen
Listen auch noch die unveränderlichen Tupel gibt.</p>
<p>Während Listen durch eckige Klammern eingeschlossen werden, verwendet man für Tupel runde Klammern. Dies
ändert jedoch nichts daran, dass bei der Indizierung mit <em>slices</em> eckige Klammern zu verwenden sind.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>primzahlen = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31)
print(primzahlen[4])
print(primzahlen[1:8:3])
print(primzahlen[::-1])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11
(3, 11, 19)
(31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2)
</pre></div>
</div>
</div>
</div>
<p>Wie schon erwähnt ist es nicht möglich, Einträge in Tupeln zu verändern.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>mein_tupel = (1, 17, 3)
mein_tupel[1] = 2
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">45</span><span class="p">],</span> <span class="n">line</span> <span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="n">mein_tupel</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">mein_tupel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

<span class="ne">TypeError</span>: &#39;tuple&#39; object does not support item assignment
</pre></div>
</div>
</div>
</div>
<p>Möchte man ein Tupel mit nur einem einzigen Element erzeugen, so muss nach dem ersten Element ein
Komma angegeben werden obwohl kein zweites Element folgt. Dies ist erforderlich, da sonst das Objekt
den Datentyp des eingeklammerten Elements besitzen würde.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>kein_tupel = (1)
print(type(kein_tupel))
ein_tupel = (1,)
print(type(ein_tupel))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;int&#39;&gt;
&lt;class &#39;tuple&#39;&gt;
</pre></div>
</div>
</div>
</div>
<p>Im ersten Fall erhält man also einen Integer und nur im zweiten Fall ein Tupel.</p>
<p>In <a class="reference internal" href="datentypen.html#variablen"><span class="std std-numref">Kapitel 3.5</span></a> und <a class="reference internal" href="funktionen.html#fdef"><span class="std std-numref">Kapitel 5.1</span></a> hatten wir Situationen kennengelernt, in denen
Tupel verwendet werden ohne dass dies durch eine Klammerung explizit ersichtlich ist. Das
folgende Beispiel, das einige Elemente der Fibonacci-Reihe berechnet, enthält in der Funktion
<code class="docutils literal notranslate"><span class="pre">fibonacci_step</span></code> zwei solche Situationen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def fibonacci_step(n1, n2):
    n1, n2 = n2, n1+n2
    return n1, n2

n1 = 0
n2 = 1
for n in range(15):
    n1, n2 = fibonacci_step(n1, n2)
    print(n2, end=&#39; &#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 
</pre></div>
</div>
</div>
</div>
<p>In der ersten Zeile des Funktionskörpers wird ein Tupel einem anderen Tupel zugewiesen, wobei
die einzelnen Werte gleich entpackt werden. In <a class="reference internal" href="datentypen.html#variablen"><span class="std std-numref">Kapitel 3.5</span></a> hatten wir eine entsprechende
Konstruktion verwendet, um die Werte zweier Variablen zu vertauschen. Die Rückgabe der beiden
Funktionsresultate geschieht letztlich auch mit Hilfe eines Tupels ohne dass eine Klammerung
erforderlich wäre.</p>
<p>Die Funktionalitäten, die wir von Listen her kennen und die nicht zu einer Modifikation der
Liste führen, existieren auch für Tupel. So können wir beispielsweise die Länge eines Tupels
wie von Listen her gewohnt bestimmen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(len(primzahlen))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11
</pre></div>
</div>
</div>
</div>
<p>Auch lässt sich das Vorhandensein eines Elements in einem Tupel wie schon bei Listen diskutiert
überprüfen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for n in range(1, 10):
    if n in primzahlen:
        print(f&#39;{n} ist eine Primzahl.&#39;)
    else:
        print(f&#39;{n} ist keine Primzahl.&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1 ist keine Primzahl.
2 ist eine Primzahl.
3 ist eine Primzahl.
4 ist keine Primzahl.
5 ist eine Primzahl.
6 ist keine Primzahl.
7 ist eine Primzahl.
8 ist keine Primzahl.
9 ist keine Primzahl.
</pre></div>
</div>
</div>
</div>
<p>Nicht zuletzt können wir auch über Tupel oder gar Tupel von Tupeln iterieren, wobei
wir die einzelnen Tupel gleich entpacken können.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from math import hypot

for x, y in ((2, 1), (-2, 4), (3, 0)):
    print(f&#39;Abstand des Punktes ({x}, {y}) vom Ursprung: {hypot(x, y):6.3f}&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Abstand des Punktes (2, 1) vom Ursprung:  2.236
Abstand des Punktes (-2, 4) vom Ursprung:  4.472
Abstand des Punktes (3, 0) vom Ursprung:  3.000
</pre></div>
</div>
</div>
</div>
</section>
<section id="zeichenketten">
<span id="strings"></span><h2><span class="section-number">6.3. </span>Zeichenketten<a class="headerlink" href="#zeichenketten" title="Link zu dieser Überschrift">#</a></h2>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition-unicode admonition">
<p class="admonition-title">Unicode</p>
<p>Mehr Information zu Unicodezeichen findet sich in <a class="reference internal" href="unicode.html#appendixunicode"><span class="std std-numref">Kapitel 12</span></a>.</p>
</div>
</aside>
<p>In vielen Beispielen sind wir bereits der Notwendigkeit begegnet, einen Text auszugeben,
der aus einem oder mehreren Zeichen besteht. In einigen Programmiersprachen wird zwischen
einzelnen Zeichen (<em>characters</em>) und Zeichenketten (<em>strings</em>) unterschieden. Dies ist zum
Beispiel in Fortran und C der Fall, wo eine Zeichenkette eine Liste von <code class="docutils literal notranslate"><span class="pre">char</span></code> darstellt.
In Python gibt es dagegen nur Zeichenketten. Diese bestehen aus einem oder mehreren
Unicodezeichen und sind wie die Tupel, die wir gerade kennengelernt haben, <em>immutable</em>,
also unveränderlich.</p>
<p>Zeichenketten werden in Python wahlweise von Hochkommas (<code class="docutils literal notranslate"><span class="pre">'</span></code>) oder Anführungszeichen (<code class="docutils literal notranslate"><span class="pre">&quot;</span></code>,
aber keine typographischen Anführungszeichen wie “”„‟), wobei am Anfang und am Ende das
gleiche Zeichen verwendet werden muss. Während Python die Art der Begrenzer egal ist, kann
diese Wahl beim Programmieren praktisch sein, wenn das andere Zeichen im Text selbst
vorkommt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s1 = &#39;Hallo&#39;
s2 = &quot;Hallo&quot;
s1 == s2
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Sollte der Begrenzer in der Zeichenkette selbst auch vorkommen, muss ihm mit einem
vorgestellten Backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>) die Sonderbedeutung an der betreffenden Stelle genommen
werden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;&quot;God said, \&#39;Let Newton be!\&#39; and all was light&quot; (Alexander Pope)&#39;
print(s)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&quot;God said, &#39;Let Newton be!&#39; and all was light&quot; (Alexander Pope)
</pre></div>
</div>
</div>
</div>
<p>Umgekehrt kann der Backslash auch dazu verwendet werden, um bestimmten Zeichen eine
besondere Bedeutung als Steuerzeichen zu geben. Verwendet man <code class="docutils literal notranslate"><span class="pre">\n</span></code>, so kann man in der
Ausgabe einen Zeilenumbruch erzeugen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &quot;Eine Zeile\nund noch eine Zeile&quot;
print(s)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Eine Zeile
und noch eine Zeile
</pre></div>
</div>
</div>
</div>
<p>Einige weitere Steuerzeichen findet man in <a class="reference internal" href="unicode.html#table-steuerzeichen"><span class="std std-numref">Tab. 12.1</span></a>.</p>
<p>Soll der Backslash nicht dazu dienen, ein Steuerzeichen anzudeuten, muss man seine
Spezialfunktion entweder mit einem weiteren Backshlash außer Kraft setzen oder die
Zeichenkette durch Voranstellen des Zeichens <code class="docutils literal notranslate"><span class="pre">r</span></code> als <em>raw string</em> kennzeichnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s1 = &quot;Eine Zeile\\nund noch eine Zeile&quot;
s2 = r&quot;Eine Zeile\nund noch eine Zeile&quot;
s1, s2
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&#39;Eine Zeile\\nund noch eine Zeile&#39;, &#39;Eine Zeile\\nund noch eine Zeile&#39;)
</pre></div>
</div>
</div>
</div>
<p>Aus der Ausgabe kann man entnehmen, dass beide Varianten für Python vollkommen äquivalent
sind.</p>
<p>Wir wir in <a class="reference internal" href="funktionen.html#dokumentation"><span class="std std-numref">Kapitel 5.2</span></a> gesehen haben, ist es in Python auch möglich,
mehrzeilige Zeichenketten direkt als solche zu definieren. Dazu muss man am Anfang und
am Ende der Zeichenkette statt nur einem Begrenzer, also <code class="docutils literal notranslate"><span class="pre">'</span></code> oder <code class="docutils literal notranslate"><span class="pre">&quot;</span></code>, jeweils drei
dieser Begrenzer setzen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;&#39;&#39;Eine Zeile
und noch eine Zeile&#39;&#39;&#39;
print(s)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Eine Zeile
und noch eine Zeile
</pre></div>
</div>
</div>
</div>
<p>Bei längeren Zeichenketten ist es manchmal auch praktisch, dass Python direkt
aufeinanderfolgende Zeichenketten, auch wenn sie über mehrere Zeilen verteilt sind,
automatisch zu einer Zeichenkette zusammenfügt, so dass man das nicht selbst explizit tun
muss.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = (&#39;Dies ist eine etwas längere Zeile, &#39;
     &#39;die noch weiter geht &#39;
     &#39;und noch weiter und noch weiter ...&#39;)
print(s)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Dies ist eine etwas längere Zeile, die noch weiter geht und noch weiter und noch weiter ...
</pre></div>
</div>
</div>
</div>
<p>Möchte man Zeichen verwenden, die sich nicht ohne Weiteres über die Tastatur eingeben
lassen, so kann man mit dem Steuerzeichen <code class="docutils literal notranslate"><span class="pre">\u</span></code> den entsprechenden Unicode-Codepoint
angeben oder mit dem Steuerzeichen <code class="docutils literal notranslate"><span class="pre">\N</span></code> die entsprechende Unicode-Beschreibung.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(&#39;\u263a \N{WHITE SMILING FACE}&#39;)
print(&#39;\u210f \N{PLANCK CONSTANT OVER TWO PI}&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>☺ ☺
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ℏ ℏ
</pre></div>
</div>
</div>
</div>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Zur Darstellung einer Zeichenkette verwendet Python standardmäßig die UTF8-Kodierung,
was in vielen Fällen die richtige Wahl sein wird. Benötigt man eine andere Kodierung,
so muss je nach Anwendungfall die Kodierung spezifiziert werden oder die
Unicode-Zeichenkette unter Angabe des <code class="docutils literal notranslate"><span class="pre">encoding</span></code>-Arguments in die entsprechende
Byte-Darstellung umgewandelt werden.</p>
</div>
<p>Wie schon eingangs erwähnt, sind Zeichenketten genauso wie Tupel unveränderlich.
Man kann Zeichenketten zwar mittels des Additionsoperators verketten, wie wir dies
bei Tupeln schon gesehen hatten. Allerdings wird dabei immer eine neue Zeichenkette
erzeugt, und dieses Vorgehen ist nicht sonderlich effizient.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s1 = &#39;Dies ist ein &#39;
s2 = &#39;Test&#39;
print(f&#39;{id(s1) = } | {id(s2) = }&#39;)
s1 = s1 + s2
print(f&#39;{id(s1) = }&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>id(s1) = 139969708104048 | id(s2) = 139969708104176
id(s1) = 139970120804032
</pre></div>
</div>
</div>
</div>
<p>Ein besseres Verfahren besteht darin, die zusammenzusetzenden Zeichenketten in einer
Liste zu sammeln, und sie anschließend mit der <code class="xref py py-func docutils literal notranslate"><span class="pre">join()</span></code>-Methode zusammenzufügen.
Dabei handelt es sich um die Methode einer Zeichenkette, die zwischen die in der Liste
aufgeführten Zeichenketten gesetzt wird. Es kann sich dabei um eine leere Zeichenkette
handeln, wenn man die einzelnen Zeichenketten nahtlos aneinander fügen möchte. Im
folgenden Beispiel ist dagegen eine Zeichenkette sinnvoll, die aus einem Leerzeichen
besteht, aber im Prinzip könnte die Zeichenkette auch mehrere Zeichen umfassen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>stringlist = [&#39;Einführung&#39;, &#39;in&#39;, &#39;Prinzipien&#39;, &#39;der&#39;, &#39;Programmierung&#39;]
print(&#39;&#39;.join(stringlist))
print(&#39; &#39;.join(stringlist))
print(&#39;--&#39;.join(stringlist))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>EinführunginPrinzipienderProgrammierung
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Einführung in Prinzipien der Programmierung
Einführung--in--Prinzipien--der--Programmierung
</pre></div>
</div>
</div>
</div>
<p>Neben dem Additionsoperator ist auch der Multiplikationsoperator zwischen einer
Zeichenkette und einem Integer definiert ähnlich wie wir das bereits bei Listen
gesehen hatten. Die ist beispielsweise praktisch, wenn man in einer Ausgabe
einen Trennstrich einer bestimmten Länge setzen möchte.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(&#39;-&#39;*40)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>----------------------------------------
</pre></div>
</div>
</div>
</div>
<p>Für Zeichenketten gibt es die gleichen Möglichkeiten des <em>slicing</em>, die wir auch von den
Tupeln her kennen. Eine Veränderung einzelner oder mehrere Zeichen analog zu den Listen
ist dagegen nicht möglich.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;Einführung in Prinzipien der Programmierung&#39;
print(f&#39;{s[14:24] = }&#39;)
print(f&#39;{s[-14:] = }&#39;)
print(f&#39;{s[1::2] = }&#39;)
print(f&#39;{s[::-1] = }&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>s[14:24] = &#39;Prinzipien&#39;
s[-14:] = &#39;Programmierung&#39;
s[1::2] = &#39;ifhugi rniindrPormirn&#39;
s[::-1] = &#39;gnureimmargorP red neipiznirP ni gnurhüfniE&#39;
</pre></div>
</div>
</div>
</div>
<p>Wie bei Listen und Tupeln lässt sich auch überprüfen, ob oder wo eine Zeichenkette in einer
anderen Zeichenkette vorhanden ist. Ist die gesuchte Zeichenkette nicht vorhanden, so
erhält man einen <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>, den man mit einer <code class="docutils literal notranslate"><span class="pre">try…except</span></code>-Konstruktion behandeln kann,
wie wir in <a class="reference internal" href="kontrollstrukturen.html#exceptions"><span class="std std-numref">Kapitel 4.4</span></a> gesehen hatten.</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;Einführung in Prinzipien der Programmierung&#39;
print(&#39;in&#39; in s)
print(s.index(&#39;in&#39;))
print(s.index(&#39;x&#39;))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
1
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ValueError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">62</span><span class="p">],</span> <span class="n">line</span> <span class="mi">4</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;in&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;in&#39;</span><span class="p">))</span>
<span class="ne">----&gt; </span><span class="mi">4</span> <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>

<span class="ne">ValueError</span>: substring not found
</pre></div>
</div>
</div>
</div>
<p>Wie über Listen oder Tupel kann man auch über Zeichenketten iterieren. Man
erhält dann nacheinander die einzelnen Zeichen der Zeichenkette.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for c in &#39;ABC&#39;:
    print(c)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A
B
C
</pre></div>
</div>
</div>
</div>
<p>Python stellt auch eine Reihe von Methoden spezifisch für Zeichenketten zur Verfügung, aus denen
wir hier nur eine kleine Auswahl ansprechen wollen. Einen vollständigen Überblick bietet die
Dokumentation unter dem Stichwort
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#string-methods">String Methods</a>.</p>
<p>Häufig steht man vor der Aufgabe, überschüssige Leerzeichen um eine Zeichenkette herum oder
einen Zeilenumbruch am Ende einer Zeichenkette zu entfernen. Die geht mit den Methoden <code class="xref py py-func docutils literal notranslate"><span class="pre">strip()</span></code>
für beide Seiten, <code class="xref py py-func docutils literal notranslate"><span class="pre">lstrip()</span></code> für die linke und <code class="xref py py-func docutils literal notranslate"><span class="pre">rstrip()</span></code> für die rechte Seite der
Zeichenkette. Ohne Argumente werden dabei Leerzeichen entfernt. Alternativ kann man eine Zeichenkette
angeben, die die zu entfernenden Zeichen enthält.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;   Hallo &#39;
print(f&#39;|{s.lstrip()}|&#39;)
print(f&#39;|{s.rstrip()}|&#39;)
print(f&#39;|{s.strip()}|&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|Hallo |
|   Hallo|
|Hallo|
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;Hallo\n&#39;
print(s)
print(&#39;-&#39;*10)
print(s.rstrip(&#39;\n&#39;))
print(&#39;-&#39;*10)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Hallo

----------
Hallo
----------
</pre></div>
</div>
</div>
</div>
<p>Im letzten Beispiel erkennt man den ursprünglich vorhandenen Zeilenumbruch an der Leerzeile in
der Ausgabe.</p>
<p>Beim Vergleichen von Zeichenketten kann es nützlich sein, unabhängig von der Groß- und
Kleinschreibung zu sein. Dann helfen die Methoden <code class="xref py py-func docutils literal notranslate"><span class="pre">upper()</span></code> und <code class="xref py py-func docutils literal notranslate"><span class="pre">lower()</span></code> weiter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>s = &#39;Hallo&#39;
print(s.upper(), s.lower())
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>HALLO hallo
</pre></div>
</div>
</div>
</div>
<p>Das abschließende Beispiel demonstriert, wie man einen Bruch formatiert darstellen kann. Die perfekte
Ausrichtung funktioniert natürlich nur, wenn beide Zahlen eine gerade oder eine beide eine
ungerade Anzahl von Stellen haben.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>zaehler = 12345678
nenner = 2468
s_zaehler = str(zaehler)
s_nenner = str(nenner)
maxlaenge = max(len(s_zaehler), len(s_nenner))
print(s_zaehler.center(maxlaenge))
print(&#39;-&#39;*maxlaenge)
print(s_nenner.center(maxlaenge))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>12345678
--------
  2468  
</pre></div>
</div>
</div>
</div>
</section>
<section id="dictionaries">
<span id="id3"></span><h2><span class="section-number">6.4. </span>Dictionaries<a class="headerlink" href="#dictionaries" title="Link zu dieser Überschrift">#</a></h2>
<p>Den letzten zusammengesetzten Datentyp, den wir in diesem Kapitel besprechen
wollen, sind Dictionaries oder auch <em>hash tables</em>, die Schlüsseln (<em>key</em>) Werte
(<em>value</em>) zuordnen. Man kann sich diese Objekte wie Telefonbücher oder Wörterbücher
vorstellen, in denen man unter geordneten Schlüsseln schnell den richtigen Eintrag
finden kann und dort die gesuchte Information nachschlagen kann.</p>
<p>Betrachten wir ein Beispiel, um eine bessere Vorstellung von Dictionaries zu bekommen.
Konkret wollen wir Informationen über die Atommasse einiger Elemente zusammenstellen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>atommasse = {&#39;H&#39;: 1.008, &#39;He&#39;: 4.002602, &#39;Li&#39;: 6.94, &#39;Be&#39;: 9.0121831}
atommasse[&#39;Li&#39;]
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6.94
</pre></div>
</div>
</div>
</div>
<p>In der ersten Zeile ist zu sehen, wie einem Schlüssel, hier das chemische Symbol, ein
Wert, im Beispiel die zugehörige Atommasse, zugeordnet wird. Die zweite Zeile zeigt,
wie man den Wert unter Angabe des Schlüssels erhalten kann. Sehen wir uns die beiden
Zeilen etwas genauer an. Im Gegensatz zu Listen, deren Einträge durch eckige Klammern
begrenzt sind, und Tupeln, die durch runde Klammern eingeschlossen werden, werden
für Dictionaries in Python geschweifte Klammern verwendet. Die durch Kommas getrennten
Einträge bestehen aus dem bereits erwähnten Paar von Schlüssel und Wert, die durch einen
Doppelpunkt getrennt sind.</p>
<p>Welche Objekte sind nun als Schlüssel und Wert zugelassen? Für Schlüsseln muss
sich ein sogenannten Hashwert berechnen lassen, also eine ganze Zahl, die den
Schlüssel charakterisiert. Da sich ein Hashwert nur für unveränderliche Objekte
wie numerische Datentypen, Tupel oder Zeichenketten definieren lassen, sind Listen
und Dictionaries selbst nicht für Schlüssel zulässig. An dieser Stellen erkennen wir
einen Vorteil, den Tupel gegenüber Listen bieten. Andererseits können die Werte sowohl
unveränderliche als auch unveränderliche Objekte sein. Das bedeutet zum Beispiel, dass
eine Liste ein Wert sein könnte und diese Liste im Programmlauf potentiell auch verändert
werden kann. Im Übrigen ist es nicht notwendig, dass alle Schlüssel vom gleichen Datentyp
sein müssen und auch für die Werte ist dies nicht erforderlich.</p>
<p>Wie wir gerade schon angedeutet haben, sind Dictionaries veränderbar, also <em>mutable</em>. Zu
einem Dictionary kann man weitere Schlüssel-Wert-Paare hinzufügen. Dazu verwendet man wie
schon beim Auslesen von Werten in unserem ersten Beispiel eckige Klammern, die den Schlüssel
einschließen. Diese Notation ist analog zur Indizierung von Listen mit Hilfe von <em>slices</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>atommasse[&#39;B&#39;] = 10.81
print(atommasse)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;H&#39;: 1.008, &#39;He&#39;: 4.002602, &#39;Li&#39;: 6.94, &#39;Be&#39;: 9.0121831, &#39;B&#39;: 10.81}
</pre></div>
</div>
</div>
</div>
<p>Offenbar ändert sich die Reihenfolge der bisherigen Einträge durch die Hinzufügung
nicht. Man darf allerdings nicht davon ausgehen, dass dies auch in anderen Programmiersprachen,
die Dictionaries oder entsprechende Datentypen zur Verfügung stellen, auch der Fall ist.
Tatsächlich ist dieses Verhalten auch in Python erst seit der Version 3.6 realisiert, die
eine neue Implementation von Dictionaries enthielt.</p>
<p>Wenn man versucht, auf den Wert zu einem nicht existierenden Schlüssel zuzugreifen, so erhält
man einen <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>, den man mit der üblichen <code class="docutils literal notranslate"><span class="pre">try…except</span></code>-Konstruktion behandeln könnte</p>
<div class="cell tag_raises-exception docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>atommasse[&#39;O&#39;]
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyError</span><span class="g g-Whitespace">                                  </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">70</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">atommasse</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">]</span>

<span class="ne">KeyError</span>: &#39;O&#39;
</pre></div>
</div>
</div>
</div>
<p>Möchte man nur wissen, ob ein Schlüssel im Dictionary vorhanden ist und interessiert man sich
nicht für den zugehörigen Wert, kann man folgendermaßen vorgehen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&#39;B&#39; in atommasse
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Iteriert man über ein Dictionary, so erhält man die darin enthaltenen Schlüssel.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for k in atommasse:
    print(k, end=&quot;, &quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>H, He, Li, Be, B, 
</pre></div>
</div>
</div>
</div>
<p>Benötigt man auch die zugehörigen Werte, so kann man die <code class="xref py py-func docutils literal notranslate"><span class="pre">items()</span></code>-Methode verwenden, die
Tupel aus Schlüssel und zugehörigem Wert liefert. Es ist durchaus üblich, aber nicht zwingend,
die entsprechenden Variablen beim Entpacken des Tupels mit <code class="docutils literal notranslate"><span class="pre">k</span></code> für <em>key</em> und <code class="docutils literal notranslate"><span class="pre">v</span></code> für <em>value</em>
zu bezeichnen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for k, v in atommasse.items():
    print(f&#39;{k:2s} | {v:5.2f}&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>H  |  1.01
He |  4.00
Li |  6.94
Be |  9.01
B  | 10.81
</pre></div>
</div>
</div>
</div>
<p>Wir wollen hier nicht alle Möglichkeiten im Detail besprechen, die für die Arbeit mit
Dictionaries in Python zur Verfügung stehen, sondern verweisen an dieser Stelle auf
den <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">entsprechenden Abschnitt in der Python-Dokumentation</a>.
Stattdessen wollen wir die Anwendung von Dictionaries an zwei Anwendungsbeispielen
demonstrieren und abschließend noch das Versprechen aus <a class="reference internal" href="kontrollstrukturen.html#ifelse"><span class="std std-numref">Kapitel 4.3</span></a> einlösen
und zeigen, wie man Dictionaries als Ersatz für Mehrfachverzweigungen verwenden kann.</p>
<p>Im ersten Beispiel wollen wir die Häufigkeiten von Zeichen in einem Text bestimmen.
Die Idee ist, hierzu ein Dictionary zu verwenden, in dem die Zeichen die Schlüssel
bilden und die zugehörigen Werte die Zähler darstellen, die sukzessive hochgezählt
werden. Dazu beginnen wir mit einem leeren Dictionary <code class="docutils literal notranslate"><span class="pre">counter</span></code>. Bei der Iteration
über die Zeichen des Textes inkrementieren wir immer den entsprechenden Eintrag.
Allerdings wird bei jeden neuen Zeichen ein <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> auftreten, da der entsprechende
Eintrag noch nicht vorhanden ist. Wir können dieses Problem mit in einer
<code class="docutils literal notranslate"><span class="pre">try…except</span></code>-Konstruktion behandeln oder aber einfach den Wert zu dem neuen Schlüssel
initialisieren.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>text = &#39;Abrakadabra&#39;
counter = {}
for c in text:
    if c not in counter:
        counter[c] = 0
    counter[c] = counter[c] + 1

occurrences = list(counter.items())
for c, n in sorted(occurrences, key=lambda x: -x[1]):
    print(f&#39;{c}: {n}&#39;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a: 4
b: 2
r: 2
A: 1
k: 1
d: 1
</pre></div>
</div>
</div>
</div>
<p>Im unteren Teil der Lösung konstruieren wir uns zunächst eine Liste aus Tupeln, die
jeweils den Schlüssel und den zugehörigen Wert enthalten. Um in der Ausgabe die
häufigsten Buchstaben zuerst auflisten zu können, verwenden wir hier eine Lambda-Funktion,
die nach dem zweiten Element des Tuples, also dem Wert im Dictionary, sortiert. Das
Minuszeichen sorgt dabei dafür, dass die höheren Wert zuerst kommen.</p>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Die drei Zeilen in der ersten <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife lassen sich in Python einfacher schreiben,
da Werte aus einem Dictionary mit Hilfe der <code class="xref py py-func docutils literal notranslate"><span class="pre">get()</span></code>-Methode abgefragt werden können,
die es auch erlaubt, einen Defaultwert für den Fall anzugeben, dass der Schlüssel nicht
existiert. In der <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife könnte man also einfach</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">counter</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>schreiben.</p>
</div>
<p>Um die Verwendung von Listen als Werten von Dictionaries zu illustrieren, wollen wir nun
eine Liste von Worten nach ihrer Länge in Gruppen einteilen. Das Vorgehen ist ähnlich
wie im vorigen Beispiel. Allerdings müssen wir hier zunächst den Schlüssel bestimmen
was wir einmal zu Beginn jedes Durchlaufs durch die <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife erledigen. Wie wir
am Ende der Schleife sehen, können wir den neuen Eintrag direkt an die betreffende Liste
im Dictionary anhängen. Es ist also nicht nötig, eine neue Liste zu erzeugen und diese
im Dictionary dem entsprechenden Eintrag zuzuweisen. Die Ausgabe des Dictionaries vereinfachen
wir dadurch, dass wir <code class="xref py py-func docutils literal notranslate"><span class="pre">pprint()</span></code>-Funktion aus dem <a class="reference external" href="https://docs.python.org/3/library/pprint.html">pprint-Modul der Standardbibliothek</a> verwenden.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from pprint import pprint

fruechte = (&#39;Apfel&#39;, &#39;Birne&#39;, &#39;Banane&#39;, &#39;Heidelbeere&#39;, &#39;Kirsche&#39;, &#39;Traube&#39;) 
gruppen = {}
for frucht in fruechte:
    key = len(frucht)
    if key not in gruppen:
        gruppen[key] = []
    gruppen[key].append(frucht)

pprint(gruppen)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{5: [&#39;Apfel&#39;, &#39;Birne&#39;],
 6: [&#39;Banane&#39;, &#39;Traube&#39;],
 7: [&#39;Kirsche&#39;],
 11: [&#39;Heidelbeere&#39;]}
</pre></div>
</div>
</div>
</div>
<div class="admonition-weiterfuhrender-hinweis admonition">
<p class="admonition-title">Weiterführender Hinweis</p>
<p>Auch hier können die letzten drei Zeilen der <code class="docutils literal notranslate"><span class="pre">for</span></code>-Schleife vereinfacht werden. Hierzu
benötigt man aber die <code class="xref py py-func docutils literal notranslate"><span class="pre">setdefault()</span></code>-Methode des Dictionaries, die bei einem
fehlenden Schlüssel den entsprechenden Eintrag im Dictionary anlegt und mit dem angegebenen
Defaultwert befüllt. Man könnte also einfacher</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">gruppen</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frucht</span><span class="p">)</span>
</pre></div>
</div>
<p>schreiben.</p>
</div>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition-literaturhinweis admonition">
<p class="admonition-title">Literaturhinweis</p>
<p>Das Pascal-Beispiel ist K. Jensen, N. Wirth, <a class="reference external" href="https://doi.org/10.1007/978-3-662-21554-8">PASCAL User Manual and Report</a>, S. 31 (Springer, 1974) entnommen.</p>
</div>
</aside>
<p>In <a class="reference internal" href="kontrollstrukturen.html#ifelse"><span class="std std-numref">Kapitel 4.3</span></a> hatten wir unter anderem die Möglichkeit von Mehrfachverzweigungen
angesprochen, aber auch darauf verwiesen, dass längliche <code class="docutils literal notranslate"><span class="pre">if…elif…else</span></code>-Konstruktionen
häufig mit Hilfe von Dictionaries vermieden werden können. Damit erhält man in Python
einen Ersatz für <code class="docutils literal notranslate"><span class="pre">case</span></code>- oder <code class="docutils literal notranslate"><span class="pre">switch</span></code>-Anweisungen, die in anderen Programmiersprachen
existieren.</p>
<p>Zur Illustration verwenden wir ein konkretes Anwendungsbeispiel für die <code class="docutils literal notranslate"><span class="pre">case</span></code>-Anweisung
in der Programmiersprache Pascal.</p>
<div class="highlight-pascal notranslate"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">i</span> <span class="k">of</span>
  <span class="mi">0</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="mi">1</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
  <span class="mi">2</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
  <span class="mi">3</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
  <span class="mi">4</span><span class="o">:</span> <span class="n">x</span> <span class="o">:=</span> <span class="nb">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">;</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Hierbei wird abhängig vom Wert des Integers <code class="docutils literal notranslate"><span class="pre">i</span></code> eine von verschiedenen mathematischen
Funktionen ausgeführt. Diese Problemstellung könnten wir in Python mit einer <code class="docutils literal notranslate"><span class="pre">if…elif</span></code>-Konstruktion
realisieren. Besser ist aber die Lösung mit Hilfe eines Dictionaries, wobei als Schlüssel
die Zahlen 0 bis 4 verwendet werden und die zugehörigen Werte die gewünschten Funktionen sind.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from math import cos, exp, log, sin

funktion = {0: lambda x: 0,
            1: sin,
            2: cos,
            3: exp,
            4: log}

x = 2
for i in range(5):
    print(funktion[i](x))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0
0.9092974268256817
-0.4161468365471424
7.38905609893065
0.6931471805599453
</pre></div>
</div>
</div>
</div>
<p>Hier haben wir ausgenutzt, dass Funktionen in Python Bürger erster Klasse sind,
die somit auch als Werte in Dictionaries in Frage kommen. Außerdem haben wir es
im ersten Eintrag des Dictionaries mit einer Lambda-Funktion vermieden, extra
eine Funktion zu definieren, die nichts anderes tut als den Wert Null
zurückzugeben. Betrachten wir noch die letzte Zeile, die auf den ersten Blick
vielleicht etwas verwirrend aussieht. Hier wird mit <code class="docutils literal notranslate"><span class="pre">funktion[i]</span></code> zunächst das
benötigte Funktionsobjekt beschafft, wobei die Variable <code class="docutils literal notranslate"><span class="pre">i</span></code> den entsprechenden
Schlüssel enthält. Diese Funktion kann nun in der üblichen Weise aufgerufen werden,
womit sich der Funktionsaufruf <code class="docutils literal notranslate"><span class="pre">funktion[i](x)</span></code> erklärt.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="funktionen.html" title="zurück Seite">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">zurück</p>
            <p class="prev-next-title"><span class="section-number">5. </span>Funktionen</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="einausgabe.html" title="weiter Seite">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">weiter</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Ein- und Ausgabe</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Gert-Ludwig Ingold<br/>
  
      &copy; Copyright CC-BY.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>